<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SUAVE</title>
    <description>A multi-fidelity conceptual design environment. Its purpose is to credibly produce conceptual-level design conclusions for future aircraft incorporating advanced technologies.
</description>
    <link>http://suavecode.github.io//</link>
    <atom:link href="http://suavecode.github.io//feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 15 Aug 2017 14:45:34 -0700</pubDate>
    <lastBuildDate>Tue, 15 Aug 2017 14:45:34 -0700</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>Code Style</title>
        <description>&lt;link rel=&quot;stylesheet&quot; href=&quot;//cdn.jsdelivr.net/highlight.js/8.6/styles/default.min.css&quot; /&gt;

&lt;script src=&quot;//cdn.jsdelivr.net/highlight.js/8.6/highlight.min.js&quot;&gt;&lt;/script&gt;

&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;

&lt;h2 id=&quot;suave-code-style-guide&quot;&gt;SUAVE Code Style Guide&lt;/h2&gt;

&lt;p&gt;SUAVE is built on a slightly modified PEP8 style guide, with changes made to implement a data-oriented view of the code.  To help support discovering code, the SUAVE folder structure explicitly mirrors the package structure.  Flexibility of the package structure is important, so in general all objects live in their own file, with the same file name as the object name.  In order to maintain a separation between Analysis and Data structures, there are often parallel package trees inside the main branches of the package, like SUAVE.Methods.Aerodynamics and SUAVE.Analysis.Aerodynamics.  Where possible the names of fields that live in the SUAVE package are written out verbosely, avoiding jargon built on mathematical variable names or acronyms. &lt;/p&gt;

&lt;p&gt;Templates for new methods and objects can be found in the SUAVE repo’s &lt;a href=&quot;https://github.com/suavecode/SUAVE/tree/develop/templates&quot;&gt;templates&lt;/a&gt; folder.&lt;/p&gt;

&lt;h3 id=&quot;naming-convention&quot;&gt;Naming Convention&lt;/h3&gt;

&lt;p&gt;In terms of typography – &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;any_variable_name&lt;/code&gt; - lower case with underscore &lt;br /&gt;
 This includes working variables and instantiated objects.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;field_name&lt;/code&gt; - lower case with underscore
 Any field of an object should be lower case.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;function_name&lt;/code&gt; - lower case with underscore&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Class_Type&lt;/code&gt; - upper case with underscore &lt;br /&gt;
 The underscores are chosen here to permit the inclusion of acronyms if needed and to maintain symmetry with field name styling.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Package_Name&lt;/code&gt; - upper case with underscore &lt;br /&gt;
 For example folders within the SUAVE package.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In terms of naming –&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Chunk similar field types under a containing field&lt;/li&gt;
  &lt;li&gt;Bias names towards being specific&lt;/li&gt;
  &lt;li&gt;Write out field name verbosely, but try to keep short&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;development-life-cycle&quot;&gt;Development Life Cycle&lt;/h3&gt;

&lt;p&gt;As you develop new features for SUAVE, this is generally how you can expect your feature to evolve, in terms of its level of abstraction, and where it lives.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Prototype &lt;br /&gt;
Either a new function or class.  You may want to test these within a separate folder. If you are developing a new analysis approach, for example for aerodynamics or weights, you can usually start with a function.  If you are working off of an object like a wing, you can abstract the objects as needed.  Generally the lowest level object you’ll use is the SUAVE.Core.Data class.  &lt;br /&gt;
A lot of development can be accomplished in a local environment.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Initial Integration &lt;br /&gt;
Once you’re comfortable that your new feature works robustly, and that it has been tested, it’s time to integrate it into SUAVE.  Here are some tips for identifying where it could live.
    &lt;ul&gt;
      &lt;li&gt;SUAVE.Methods - if it’s a python function.  Ping the &lt;a href=&quot;http:suavecode.github.io/forum&quot;&gt;forum&lt;/a&gt; if you want to double check your decision!&lt;/li&gt;
      &lt;li&gt;SUAVE.Analyses - if it’s an object that manages an analysis like aerodynamics&lt;/li&gt;
      &lt;li&gt;SUAVE.Components - if it’s a data storage container for a vehicle component like a wing or landing gear&lt;/li&gt;
      &lt;li&gt;SUAVE.Attributes - if it’s a data storage container for any other type of object, like atmospheres or water&lt;br /&gt;&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;At this point you might want to initiate a pull request to contribute the code back to the main repository.&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Full-Blown Subpackage &lt;br /&gt;
As you write more code, and follow the SUAVE style of keeping one file per object, you will need to create a folder to contain a subpackage.  This step may come later in the life of your code, so don’t rush to it if you don’t need the extra overhead.&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Tue, 10 Jan 2017 05:25:00 -0800</pubDate>
        <link>http://suavecode.github.io//guides/style.html</link>
        <guid isPermaLink="true">http://suavecode.github.io//guides/style.html</guid>
        
        
        <category>documentation</category>
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Using the Documentation</title>
        <description>&lt;h3 id=&quot;how-to-read-and-write-the-documentation&quot;&gt;How to Read (and Write) the Documentation&lt;/h3&gt;

&lt;p&gt;This is an explanation of how documentation is built in SUAVE so that the user can know what to look for and how to write it if they wish to add their own code. The doxygen page is available &lt;a href=&quot;/doxygen&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;docstrings&quot;&gt;Docstrings&lt;/h3&gt;

&lt;p&gt;All classes and functions in SUAVE have docstrings have docstrings. These give the user an understanding of what the function does and information on the input and output variables. &lt;/p&gt;

&lt;h4 id=&quot;classes&quot;&gt;Classes&lt;/h4&gt;

&lt;p&gt;For a class, the docstring has three parts:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;General description&lt;/li&gt;
  &lt;li&gt;Assumptions&lt;/li&gt;
  &lt;li&gt;Source&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The general description provides a brief summary of what the class is used for. Assumptions list any significant assumptions are important in how it is used. This may be listed as None or N/A if there are no important assumptions. The source section should provide the general source of methods in the class. If there is no overall source, a message like ‘see sources in functions’ may be appropriate. There are also cases where a source is not relevant, such as simple geometric functions, and may also be listed as None or N/A.&lt;/p&gt;

&lt;h4 id=&quot;class-docstring-template&quot;&gt;Class Docstring Template&lt;/h4&gt;

&lt;p&gt;This is the general template that can be used when creating a new class. It should be placed directly under the class declaration.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;&quot;&quot;&amp;lt;Description&amp;gt;

Assumptions:
&amp;lt;any assumptions&amp;gt;

Source:
&amp;lt;source&amp;gt;
&quot;&quot;&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;functions&quot;&gt;Functions&lt;/h4&gt;

&lt;p&gt;For functions there are six categories:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Description&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is a general description of what the function does. It should also include any key information that does not fit into one of the other categories.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Assumptions&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This should contain any assumptions made by the function. None or N/A can be used if none are used.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Source&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The source of any methods that have been implemented. Simple methods like basic geometric relations do not need a source.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Inputs&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This should contain any variables or functions passed to the function. If the passed variable is a data structure, the components that are used should be listed. Each item should include a description if it is not obvious from the name. It should also include any relevant units. In addition, information about the variable type or any other information that might be important can be added here.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Outputs&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This should contain the same information as in the inputs. It may also contain information on variables that are modified but not explicitly returned.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Properties Used&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This carries the same information as input and outputs. It typically contains variables that are properties of the parent class but are not modified. There is some overlap with inputs and outputs, but either category is acceptable as long as the variable is documented.&lt;/p&gt;

&lt;h4 id=&quot;function-docstring-template&quot;&gt;Function Docstring Template&lt;/h4&gt;

&lt;p&gt;This is a template docstring:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &quot;&quot;&quot;&amp;lt;Description&amp;gt;
    
    Assumptions:
    &amp;lt;any assumptions&amp;gt;
    
    Source:
    &amp;lt;source&amp;gt;
    
    Inputs:
    &amp;lt;input1&amp;gt; &amp;lt;units&amp;gt;
    &amp;lt;input2&amp;gt; &amp;lt;units&amp;gt;
    ..
    
    Outputs:
    &amp;lt;output1&amp;gt; &amp;lt;units&amp;gt;
    &amp;lt;output2&amp;gt; &amp;lt;units&amp;gt;
    ..

    Properties Used:
    &amp;lt;property1&amp;gt; &amp;lt;units&amp;gt;
    &amp;lt;property2&amp;gt; &amp;lt;units&amp;gt;
    ..
    &quot;&quot;&quot;   
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;doxygen-grouping-tags&quot;&gt;Doxygen Grouping Tags&lt;/h3&gt;

&lt;p&gt;Tags are used to put files into groups that match the SUAVE file structure. &lt;code class=&quot;highlighter-rouge&quot;&gt;@defgroup&lt;/code&gt; tags define a group and should be placed in the init file. An example is shown here:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;## @defgroup Analyses-Aerodynamics Aerodynamics
# These are the analyses that control aerodynamic evaluations.
# @ingroup Analyses
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;In this example, &lt;code class=&quot;highlighter-rouge&quot;&gt;Analyses-Aerodynamics&lt;/code&gt; is the doxygen tag for the group, while the group appears in the documentation as &lt;code class=&quot;highlighter-rouge&quot;&gt;Aerodynamics&lt;/code&gt;, the next part of the string. The tag is based on the file structure (Analyses/Aerodynamics here). Since this is a subgroup of Analyses, &lt;code class=&quot;highlighter-rouge&quot;&gt;@ingroup Analyses&lt;/code&gt; is used here, with &lt;code class=&quot;highlighter-rouge&quot;&gt;Analyses&lt;/code&gt; as the doxygen tag for the next level up.&lt;/p&gt;

&lt;p&gt;In files, the &lt;code class=&quot;highlighter-rouge&quot;&gt;@ingroup&lt;/code&gt; tag should be inserted before all classes and stand-alone functions. The tag should match the tag in the folder init file’s &lt;code class=&quot;highlighter-rouge&quot;&gt;@defgroup&lt;/code&gt; string.&lt;/p&gt;
</description>
        <pubDate>Mon, 09 Jan 2017 05:25:00 -0800</pubDate>
        <link>http://suavecode.github.io//guides/docs.html</link>
        <guid isPermaLink="true">http://suavecode.github.io//guides/docs.html</guid>
        
        
        <category>documentation</category>
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Mission Solver Structure</title>
        <description>&lt;h2 id=&quot;mission-solver-code-structure&quot;&gt;Mission Solver Code Structure&lt;/h2&gt;

&lt;p&gt;This is a high level overview of how the mission solver functions. The purpose is to show the structure that is used for an existing mission, and show where changes should be made if different functionality is desired.&lt;/p&gt;

&lt;h3 id=&quot;file-structure&quot;&gt;File Structure&lt;/h3&gt;

&lt;p&gt;Mission scripts are split into two folders in the SUAVE repository. The first is in trunk/SUAVE/&lt;strong&gt;Analyses/Mission&lt;/strong&gt;/Segments, and the second is in trunk/SUAVE/&lt;strong&gt;Methods/Missions&lt;/strong&gt;/Segments. As with other types of analyses and methods, the distinction between these is that the Analyses folder contains classes that are built to use functions stored in the Methods folder. This division is done to make it easier to build new analysis classes using a mix of available methods. &lt;/p&gt;

&lt;p&gt;A typical mission segment analysis file contains four keys parts. The first specifies default user inputs, unknowns, and residuals. The inputs are used to provide the analysis with conditions that need to be met, while the unknowns and residuals are used as part of the solution process. The second sets the initialization functions for the analysis, which are run at the beginning. The third picks the convergence method and specifies the functions that will be used during iteration. The fourth finalizes the data and processes it for results output.&lt;/p&gt;

&lt;h3 id=&quot;initialization&quot;&gt;Initialization&lt;/h3&gt;

&lt;p&gt;For this tutorial, we will be considering the constant speed constant altitude cruise segment. The files are available &lt;a href=&quot;https://github.com/suavecode/SUAVE/blob/develop/trunk/SUAVE/Analyses/Mission/Segments/Cruise/Constant_Speed_Constant_Altitude.py&quot;&gt;here (Analysis)&lt;/a&gt; and &lt;a href=&quot;https://github.com/suavecode/SUAVE/blob/develop/trunk/SUAVE/Methods/Missions/Segments/Cruise/Constant_Speed_Constant_Altitude.py&quot;&gt;here (Method)&lt;/a&gt;. This class also inherits information from more general segment classes, which include many of the processing functions. As with other segments, the user will specify key conditions. For this case, altitude, air speed, and distance are the necessary inputs. If the user does not specify an altitude, it will be taken automatically from the last value in the previous segment. These inputs must be specified in some way for the mission segment to be evaluated. They are shown below as well:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;self.altitude  = None
self.air_speed = 10. * Units[&#39;km/hr&#39;]
self.distance  = 10. * Units.km
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The other set of segment specific initial values are the values used for solving the segment (typically this means satisfying a force balance at every evaluation point). These can be changed by the user if needed, but the default values should perform fine for most cases. &lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;self.state.unknowns.throttle   = ones_row(1) * 0.5
self.state.unknowns.body_angle = ones_row(1) * 0.0
self.state.residuals.forces    = ones_row(2) * 0.0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Here throttle and body angle are the unknowns, and the values shown here are the values they will start at. The residuals will be computed based on these unknowns, so their initial value is not important. Instead they are initialized just to create the necessary data structure. The ones_row line will create a numpy array with the number of elements needed for evaluation.&lt;/p&gt;

&lt;h3 id=&quot;evaluation-details&quot;&gt;Evaluation Details&lt;/h3&gt;

&lt;p&gt;Most of the missions in SUAVE, including this one, are broken into several points in time based on a Chebyshev polynomial. This causes the points to be closer together at either end of the segment. The choice of a Chebyshev polynomial (which creates cosine spacing) provides better convergence and smoothness properties versus other methods such as linear spacing.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://suave.stanford.edu/images/drag_components_2.png&quot; width=&quot;800&quot; height=&quot;234&quot; /&gt;&lt;/p&gt;

&lt;p&gt;At each of these points the aerodynamic analysis is queried to find CL and CD, which are then converted to lift and drag. These values will be dependent on the body angle unknown and other aerodynamic parameters. Thrust is found from the vehicle’s energy network, which is dependent on the throttle unknown. A weight is determined by looking at the initial weight and subsequent mass rate (typically corresponding with fuel burn). In this cruise segment, these forces are summed in 2D and the results are put in the residuals. The functions needed to arrive these forces are found in the Update Conditions section of the Analysis file. This section is also shown below in one of the steps to create a new mission.  &lt;/p&gt;

&lt;p&gt;Once the evaluation process has been performed at all points, the unknowns and residuals are fed back to the solve routine, which in this case is scipy’s fsolve. The file that performs this process is &lt;a href=&quot;https://github.com/suavecode/SUAVE/blob/develop/trunk/SUAVE/Methods/Missions/Segments/converge_root.py&quot;&gt;here&lt;/a&gt;. This routine continues evaluating the points until convergence is reached. Once this happens, post processing is done to put the data in the results output.&lt;/p&gt;

&lt;h3 id=&quot;using-multiple-segments&quot;&gt;Using Multiple Segments&lt;/h3&gt;

&lt;p&gt;Multiple segments can be run sequentially by appending them in the desired order. Examples of this are in all the tutorial files that have an aircraft fly a full mission. In addition, the full mission can be run simultaneously will all segment constraints used together. If you are interested in doing something like this, please ask us about it on our &lt;a href=&quot;/forum&quot;&gt;forum&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&quot;process-summary&quot;&gt;Process Summary&lt;/h4&gt;

&lt;p&gt;Mission Setup&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Initializes default values for unknowns&lt;/li&gt;
  &lt;li&gt;Initializes set of functions used to determine residuals&lt;/li&gt;
  &lt;li&gt;Reads user input for segment parameters&lt;/li&gt;
  &lt;li&gt;Adds the analysis group to be used (including the vehicle and items like atmosphere)&lt;/li&gt;
  &lt;li&gt;Appends segments in order&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Evaluate&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Varies unknowns until residual convergence is reached using scipy’s fsolve&lt;/li&gt;
  &lt;li&gt;Repeats process for each segment until full mission is complete&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;adding-new-mission-segments&quot;&gt;Adding New Mission Segments&lt;/h3&gt;

&lt;p&gt;The segment described above uses two unknowns to solve force residuals in two dimensions. This general setup works well for many problems of interest, but SUAVE is designed to accommodate other mission analysis types as well. A user may want to add control surface deflection and solve for moments as well, or look at forces in all three dimensions. &lt;/p&gt;

&lt;p&gt;In addition, a user may want to modify how the mission is flown, as is done with the many other segments currently available. They may want to modify how the mission is solved, such as is done in our single point evaluation segments where finite differencing is not relevant.&lt;/p&gt;

&lt;p&gt;Here we will explain the process of modifying our constant speed constant rate climb segment to be constant throttle constant speed. This still uses 2D force balance but changes the profile. There are four functions that are modified here. The first is shown below. The functions can be found in &lt;a href=&quot;&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;&quot;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def initialize_conditions(segment,state):

    # unpack
    climb_rate = segment.climb_rate
    air_speed  = segment.air_speed   
    alt0       = segment.altitude_start 
    altf       = segment.altitude_end
    t_nondim   = state.numerics.dimensionless.control_points
    conditions = state.conditions  

    # check for initial altitude
    if alt0 is None:
        if not state.initials: raise AttributeError(&#39;initial altitude not set&#39;)
        alt0 = -1.0 * state.initials.conditions.frames.inertial.position_vector[-1,2]

    # discretize on altitude
    alt = t_nondim * (altf-alt0) + alt0
    
    # process velocity vector
    v_mag = air_speed
    v_z   = -climb_rate # z points down
    v_x   = np.sqrt( v_mag**2 - v_z**2 )
    
    # pack conditions    
    conditions.frames.inertial.velocity_vector[:,0] = v_x
    conditions.frames.inertial.velocity_vector[:,2] = v_z
    conditions.frames.inertial.position_vector[:,2] = -alt[:,0] # z points down
    conditions.freestream.altitude[:,0]             =  alt[:,0] # positive altitude in this context
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This function initializes speed and altitude based on the given climb rate, airspeed, and altitude end points. t_nondim gives nondimensional time in cosine spacing from 0 to 1 in order to pick the values at the points to be evaluated. Unfortunately, when we use constant throttle we cannot know beforehand exactly how altitude (or climb rate in this case) will vary with time, so altitude cannot be spaced with this method. Instead a different function is used to initialize conditions:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def initialize_conditions(segment,state):

    # unpack
    throttle   = segment.throttle
    air_speed  = segment.air_speed   
    alt0       = segment.altitude_start 
    altf       = segment.altitude_end
    t_nondim   = state.numerics.dimensionless.control_points
    conditions = state.conditions  

    # check for initial altitude
    if alt0 is None:
        if not state.initials: raise AttributeError(&#39;initial altitude not set&#39;)
        alt0 = -1.0 * state.initials.conditions.frames.inertial.position_vector[-1,2]

    # pack conditions  
    conditions.propulsion.throttle[:,0] = throttle
    conditions.frames.inertial.velocity_vector[:,0] = air_speed # start up value
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Here only the throttle and air speed are loaded in, and discretization of other values will need to occur later so that it is part of the iteration loop. This requires a new function that updates the altitude differentials.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def update_differentials_altitude(segment,state):

    # unpack
    t = state.numerics.dimensionless.control_points
    D = state.numerics.dimensionless.differentiate
    I = state.numerics.dimensionless.integrate

    
    # Unpack segment initials
    alt0       = segment.altitude_start 
    altf       = segment.altitude_end    
    conditions = state.conditions  

    r = state.conditions.frames.inertial.position_vector
    v = state.conditions.frames.inertial.velocity_vector
    
    # check for initial altitude
    if alt0 is None:
        if not state.initials: raise AttributeError(&#39;initial altitude not set&#39;)
        alt0 = -1.0 * state.initials.conditions.frames.inertial.position_vector[-1,2]    
    
    # get overall time step
    vz = -v[:,2,None] # Inertial velocity is z down
    dz = altf- alt0    
    dt = dz / np.dot(I[-1,:],vz)[-1] # maintain column array
    
    # Integrate vz to get altitudes
    alt = alt0 + np.dot(I*dt,vz)

    # rescale operators
    t = t * dt

    # pack
    t_initial = state.conditions.frames.inertial.time[0,0]
    state.conditions.frames.inertial.time[:,0] = t_initial + t[:,0]
    conditions.frames.inertial.position_vector[:,2] = -alt[:,0] # z points down
    conditions.freestream.altitude[:,0]             =  alt[:,0] # positive altitude in this context    

    return
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;In this function, t, D, and I are numpy arrays that allow approximate differentiation and integration. Since the total time is not known without determining the climb rate, we must first determine the time required to reach the final altitude. The line &lt;code class=&quot;highlighter-rouge&quot;&gt;dt = dz / np.dot(I[-1,:],vz)[-1]&lt;/code&gt; does this with the integrator providing the amount of altitude gained if the velocities were spread across just one second instead of the full segment time. This gives the scaling quantity &lt;code class=&quot;highlighter-rouge&quot;&gt;dt&lt;/code&gt; that is then used to get the altitude at every point in &lt;code class=&quot;highlighter-rouge&quot;&gt;alt = alt0 + np.dot(I*dt,vz)&lt;/code&gt;. The values for altitude are then are then packed for use in other functions.&lt;/p&gt;

&lt;p&gt;The above allows us to deal with discretization without a known profile, but we also must calculate the velocity in order to use this. This is done with another added function.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def update_velocity_vector_from_wind_angle(segment,state):

    # unpack
    conditions = state.conditions 
    v_mag  = segment.air_speed 
    alpha  = state.unknowns.wind_angle[:,0][:,None]
    theta  = state.unknowns.body_angle[:,0][:,None]
    
    # Flight path angle
    gamma = theta-alpha
    
    # process
    v_x =  v_mag * np.cos(gamma)
    v_z = -v_mag * np.sin(gamma) # z points down
    
    # pack
    conditions.frames.inertial.velocity_vector[:,0] = v_x[:,0]
    conditions.frames.inertial.velocity_vector[:,2] = v_z[:,0]
    
    return conditions
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This uses our new set of unknowns to determine the velocities. &lt;/p&gt;

&lt;p&gt;Additionally, since the unknowns are different we must change the function that unpacks them. Wind angle does not need to be stored so it is not included here.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def unpack_body_angle(segment,state):

    # unpack unknowns
    theta  = state.unknowns.body_angle
    
    # apply unknowns
    state.conditions.frames.body.inertial_rotations[:,1] = theta[:,0]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;We now add these functions to the segment process list.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    # --------------------------------------------------------------
    #   Initialize - before iteration
    # --------------------------------------------------------------
    initialize = self.process.initialize
    
    initialize.expand_state            = Methods.expand_state
    initialize.differentials           = Methods.Common.Numerics.initialize_differentials_dimensionless
    initialize.conditions              = Methods.Climb.Constant_Throttle_Constant_Speed.initialize_conditions
    initialize.velocities              = Methods.Climb.Constant_Throttle_Constant_Speed.update_velocity_vector_from_wind_angle
    initialize.differentials_altitude  = Methods.Climb.Constant_Throttle_Constant_Speed.update_differentials_altitude      
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;and&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    # Unpack Unknowns
    iterate.unknowns = Process()
    iterate.unknowns.mission           = Methods.Climb.Constant_Throttle_Constant_Speed.unpack_body_angle 
    
    # Update Conditions
    iterate.conditions = Process()
    iterate.conditions.velocities      = Methods.Climb.Constant_Throttle_Constant_Speed.update_velocity_vector_from_wind_angle
    iterate.conditions.differentials_a = Methods.Climb.Constant_Throttle_Constant_Speed.update_differentials_altitude
    iterate.conditions.differentials_b = Methods.Common.Numerics.update_differentials_time
    iterate.conditions.acceleration    = Methods.Common.Frames.update_acceleration
    iterate.conditions.altitude        = Methods.Common.Aerodynamics.update_altitude
    iterate.conditions.atmosphere      = Methods.Common.Aerodynamics.update_atmosphere
    iterate.conditions.gravity         = Methods.Common.Weights.update_gravity
    iterate.conditions.freestream      = Methods.Common.Aerodynamics.update_freestream
    iterate.conditions.orientations    = Methods.Common.Frames.update_orientations
    iterate.conditions.aerodynamics    = Methods.Common.Aerodynamics.update_aerodynamics
    iterate.conditions.stability       = Methods.Common.Aerodynamics.update_stability
    iterate.conditions.propulsion      = Methods.Common.Energy.update_thrust
    iterate.conditions.weights         = Methods.Common.Weights.update_weights
    iterate.conditions.forces          = Methods.Common.Frames.update_forces
    iterate.conditions.planet_position = Methods.Common.Frames.update_planet_position
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;If you have any questions that are not answered in other tutorials or the FAQ please ask on our &lt;a href=&quot;/forum&quot;&gt;forum&lt;/a&gt; page. This is also the place to go if you want help building a more elaborate evaluation, such as one that includes moments.&lt;/p&gt;
</description>
        <pubDate>Sat, 07 Jan 2017 05:25:00 -0800</pubDate>
        <link>http://suavecode.github.io//guides/mission.html</link>
        <guid isPermaLink="true">http://suavecode.github.io//guides/mission.html</guid>
        
        
        <category>documentation</category>
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Energy Networks</title>
        <description>&lt;h2 id=&quot;energy-networks&quot;&gt;Energy Networks&lt;/h2&gt;
&lt;p&gt;Energy networks are really a fancy name for your propulsion system. The reason we call them a network rather than “engine” or the like is that it encompasses far more than that. These “energy networks” are the complex systems that future aircraft will incorporate that can reduce or eliminate fuel burn. For example if you have a hybrid gas-electric aircraft you don’t have just an engine. You have an engine, a motor, batteries, a generator, a gearbox, a propeller or ducted fan, wiring, electronics… and that doesn’t include the parts inside the internal combustion engine. Modeling these systems completely is essential in designing such a vehicle.&lt;/p&gt;

&lt;p&gt;To do this we depart from the typical SUAVE structure of analyses and methods. This was done because we want to look at each component of the network individually. All components behave in their own ways. The purpose of the network is to link together every component in the system to work together.&lt;/p&gt;

&lt;h3 id=&quot;file-structure&quot;&gt;File Structure&lt;/h3&gt;
&lt;p&gt;One of the biggest sources of confusion for energy networks is the file structure. The files for every part of a network are located at trunk/SUAVE/&lt;strong&gt;Components/Energy&lt;/strong&gt;. Within that we have several subfolders.&lt;/p&gt;

&lt;h4 id=&quot;converters&quot;&gt;/Converters&lt;/h4&gt;
&lt;p&gt;Converters are defined as component that takes energy or power from one form to another. It could be electrical to mechanical, or even chemical to mechanical, etc.. Examples in this folder include a motor, a solar panel, and the compressor section of a jet engine.
#### /Distributors
Distributors move power from one part of the network to another. The common use of this is an electronic speed controller for a small UAV.
#### /Networks
This is where all the “Network” scripts that tie together all of the pieces are kept. Examples in here are a turbofan network.
#### /Peripherals
Peripherals are items that rely on the network but do not produce thrust or power for the vehicle. For example, avionics require electricity which must be accounted for.
#### /Processes
Processes are non tangible parts of a network that are necessary. For example the process is thrust. This function is useful for jet engines to combine and dimensionalize the final thrust once all the components are combined in the network.
#### /Storages
Storages, for now, include batteries. However, in the future we could have fuel tanks here. Currently fuel is only handled as a mass variation. &lt;/p&gt;

&lt;h3 id=&quot;component-example&quot;&gt;Component Example&lt;/h3&gt;
&lt;p&gt;Below is a simple example of the most basic energy component in SUAVE. All energy components are classes. The  A solar panel is a converter since it converts a photonic flux calculated by a solar radiation model and converts it to a power.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Solar_Panel.py
#
# Created:  Jun 2014, E. Botero
# Modified: Jan 2016, T. MacDonald

# ----------------------------------------------------------------------
#  Imports
# ----------------------------------------------------------------------

# suave imports
import SUAVE

from SUAVE.Components.Energy.Energy_Component import Energy_Component

# ----------------------------------------------------------------------
#  Solar_Panel Class
# ----------------------------------------------------------------------
class Solar_Panel(Energy_Component):
    
    def __defaults__(self):
        self.area       = 0.0
        self.efficiency = 0.0
    
    def power(self):
        
        # Unpack
        flux       = self.inputs.flux
        efficiency = self.efficiency
        area       = self.area
        
        p = flux*area*efficiency
        
        # Store to outputs
        self.outputs.power = p
    
        return p
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;These classes contain functions that simulate a process. Multiple functions can exist within a component. This component has defaults, inputs, and outputs. Defaults are provided that give the user an idea of what the fixed parameters of the component are. These values are set when initializing a vehicle. This is the recipe that all energy components are built off. &lt;/p&gt;

&lt;h3 id=&quot;network-scripts&quot;&gt;Network Scripts&lt;/h3&gt;
&lt;p&gt;Network scripts are the link between these components. The network script allows you to reconfigure the connection between components to create your dream propulsion system. These must be logically created as components have set inputs and outputs. For example, you can’t magically go from a battery to a propeller without anything in between. Some knowledge of the inputs and outputs are necessary, however they’re generally quite intuitive. One interesting avenue for SUAVE is that you can create networks of networks.&lt;/p&gt;

&lt;p&gt;The linking process works like this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    # step 1
    solar_flux.solar_radiation(conditions)
    # link
    solar_panel.inputs.flux = solar_flux.outputs.flux
    # step 2
    solar_panel.power()
    # link
    solar_logic.inputs.powerin = solar_panel.outputs.power
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Notice the first step above is to calculate the solar radiation. Once the solar radiation is calculated the components are linked and step 2 can continue with the the power being calculated. From there a solar logic component will use that power.&lt;/p&gt;

&lt;p&gt;The other main hallmark of a network is that they are called at every point in the mission to calculate the state of the system. Given some &lt;em&gt;conditions&lt;/em&gt; data that defines the state of the vehicle the components must provide back to the mission being solved a thrust force and a mass rate. Other outputs can be stored back to conditions, however a thrust and a mass rate must be returned.&lt;/p&gt;

&lt;h3 id=&quot;vehicle-script-setup-of-a-network&quot;&gt;Vehicle Script Setup of a Network&lt;/h3&gt;

&lt;p&gt;Here we will provide a snippet of the turbofan setup for a B737. &lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# ------------------------------------------------------------------
#  Component 3 - Low Pressure Compressor

# instantiate 
compressor = SUAVE.Components.Energy.Converters.Compressor()    
compressor.tag = &#39;low_pressure_compressor&#39;

# setup
compressor.polytropic_efficiency = 0.91
compressor.pressure_ratio        = 1.14    

# add to network
turbofan.append(compressor)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;In the above example, a compressor is added to the network. The compressor is tagged as the low_pressure_compressor to distinguish it from the high pressure compressor. The polytropic efficiency and pressure ratio are set. Finall it is appended to the network.&lt;/p&gt;
</description>
        <pubDate>Fri, 06 Jan 2017 05:25:00 -0800</pubDate>
        <link>http://suavecode.github.io//guides/energy_structure.html</link>
        <guid isPermaLink="true">http://suavecode.github.io//guides/energy_structure.html</guid>
        
        
        <category>documentation</category>
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Optimization Structure</title>
        <description>&lt;h2 id=&quot;optimization-code-structure&quot;&gt;Optimization Code Structure&lt;/h2&gt;

&lt;p&gt;This is an overview of how optimization is done in SUAVE. A specific tutorial case is also available &lt;a href=&quot;/guides/regional_jet_optimization.html&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;nexus-class&quot;&gt;Nexus Class&lt;/h3&gt;

&lt;p&gt;The Nexus class is the underlying data structure that is used for optimization. It is created to hold all data and functionality needed to link together optimizers and the various analysis modules in SUAVE. Detailed information on each of the functions can be found on our &lt;a href=&quot;/doxygen&quot;&gt;doxygen page&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;standard-optimization-file-structure&quot;&gt;Standard Optimization File Structure&lt;/h3&gt;

&lt;p&gt;These are the standard files that are used in the optimization process. They are typically stored as Optimize.py, Vehicle.py, Analysis.py, Mission.py, Procedure.py, and Plot_Mission.py. These names can be changed if desired.&lt;/p&gt;

&lt;h4 id=&quot;optimize&quot;&gt;Optimize&lt;/h4&gt;

&lt;p&gt;This is the top level file that is run to perform the optimization. Inputs, objective, constraints, and aliases are specified here. The inputs have an initial value, bounds, a scaling factor, and the units used. This provides later functions with the information needed to vary the parameters. Units.less indicates a unitless quantity. SI units are the default in SUAVE’s internal calculations, so Units.meter will not modify the internal value, while something like Units.foot will.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;problem.inputs = np.array([
    [ &#39;wing_area&#39;     ,  125.  , (   120.   ,   180.   )  ,   100.  , Units.meter**2],
    [ &#39;aspect_ratio&#39;  ,  3.3   , (   2.0    ,   6.0    )  ,   10.   , Units.less],
])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Constraints and the objective are similar. Both have scaling quantities and constraints also have bounds.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;problem.constraints = np.array([
    [ &#39;design_range_fuel_margin&#39;, &#39;&amp;gt;&#39;, 0., 1E-1, Units.less]
])

problem.objective = np.array([
    [&#39;fuel_burn_rate&#39;, 1., Units.kg/Units.s]
])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Finally we have aliases. This provides the optimization process with the position of the various parameters in the data structure. Aliases are used so that short names can be used for variables and a single variable can control multiple items in the data structure. Controlling multiple items can be important if different vehicle configurations are used at different points in the mission, and one of the vehicle parameters should change in the same way for all of the configurations. We can use * as a wildcard. This is used below to change the aspect ratio of the main wing in every vehicle configuration.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;problem.aliases = [
    [ &#39;wing_area&#39;       ,   [&#39;vehicle_configurations.base.wings.main_wing.areas.reference&#39;,
                                              &#39;vehicle_configurations.base.reference_area&#39;]],
    [ &#39;aspect_ratio&#39;    ,    &#39;vehicle_configurations.*.wings.main_wing.aspect_ratio&#39;       ],
    [ &#39;fuel_burn_rate&#39;  ,    &#39;summary.fuel_burn_rate&#39;                                      ],
]    
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This file then specifies the configurations, analyses, missions, and procedure that will be used. This are typically contained in separate files and more details on each are below. Once all of this is specified, the desired optimizer is called with the nexus class created by this setup.&lt;/p&gt;

&lt;h4 id=&quot;vehicle-setup&quot;&gt;Vehicle Setup&lt;/h4&gt;

&lt;p&gt;This contains the vehicle information such as geometric data and configurations. It is the same as the vehicle setup used for basic analysis purposes.&lt;/p&gt;

&lt;h4 id=&quot;analysis-setup&quot;&gt;Analysis Setup&lt;/h4&gt;

&lt;p&gt;This contains information on what analyses should be run for the vehicle. For example if correlation-based aerodynamics or AVL should be used for computations. It requires vehicle information from the previous step.&lt;/p&gt;

&lt;h4 id=&quot;mission-setup&quot;&gt;Mission Setup&lt;/h4&gt;

&lt;p&gt;This is also the same as the standard mission setup. It determines how the mission will be flown. It requires analysis information from the previous step.&lt;/p&gt;

&lt;h4 id=&quot;procedure&quot;&gt;Procedure&lt;/h4&gt;

&lt;p&gt;This is an optimization specific file that determines how the vehicle, analysis, or mission is modified with the input values in the optimization and also runs the mission. For example, changing the wing area will usually require changes to other wing parameters, such as root chord length. This module reads the new inputs and changes other values accordingly based on user specified processes.&lt;/p&gt;

&lt;h4 id=&quot;plotting&quot;&gt;Plotting&lt;/h4&gt;

&lt;p&gt;This function is not necessary to the optimization, but is often included in the files used and is added to the optimize main call as a way to visualize the results.&lt;/p&gt;

&lt;h3 id=&quot;optimizer-interface&quot;&gt;Optimizer Interface&lt;/h3&gt;

&lt;p&gt;The other step that must be taken to perform an optimization is to convert the standardized input above into values that can be used by the selected optimizer. This is done through a separate script for each optimizer, all of which are found in the &lt;a href=&quot;doxygen_link_here&quot;&gt;optimization folder&lt;/a&gt;. &lt;/p&gt;

&lt;p&gt;For example, if we are using PyOpt to optimize, we might use &lt;code class=&quot;highlighter-rouge&quot;&gt;output = pyopt_setup.Pyopt_Solve(problem,solver=&#39;SNOPT&#39;)&lt;/code&gt; in the main function of the top level optimizer. This function reads the inputs, constraints, and objective and converts them to a format that the selected optimizer (SNOPT here) can understand.&lt;/p&gt;

&lt;h3 id=&quot;evaluation-process&quot;&gt;Evaluation Process&lt;/h3&gt;

&lt;p&gt;This shows the typical evaluation process, including where items like inputs and aliases are used. This chart assumes a single objective call, but some optimizers will include calls such as &lt;code class=&quot;highlighter-rouge&quot;&gt;all_constraints&lt;/code&gt; which require another evaluation. If the evaluation is a duplicate, data from the previous evaluation will be used instead of stepping through the procedure again.&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://suave.stanford.edu/images/opt_flow.png&quot; width=&quot;600&quot; height=&quot;338&quot; /&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3 id=&quot;incorporating-multi-fidelity&quot;&gt;Incorporating Multi-fidelity&lt;/h3&gt;

&lt;p&gt;Multiple levels of fidelity are designed to be relatively easy to incorporate in SUAVE, but there are still a few things to keep in mind. First, the chosen optimizer must support multi-fidelity and be able to change the &lt;code class=&quot;highlighter-rouge&quot;&gt;nexus.fidelity_level&lt;/code&gt; value. Once this is done, it is also important to remember that the mission is set up based on the analyses. This means that if a change is made to  the analyses then the mission must be rebuilt with the new settings. As an example, code below for changing the analysis level is shown. This is a function that has been added to the procedure file.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def set_fidelity_level(nexus):
    
    if nexus.has_key(&#39;fidelity_level&#39;) == False:
        print &#39;Fidelity level not set, defaulting to 1&#39;
        nexus.fidelity_level = 1

    if nexus.fidelity_level == 2:
        aerodynamics = SUAVE.Analyses.Aerodynamics.Supersonic_OpenVSP_Wave_Drag()
        aerodynamics.settings.number_slices    = 20
        aerodynamics.settings.number_rotations = 10        
    elif nexus.fidelity_level == 1:
        aerodynamics = SUAVE.Analyses.Aerodynamics.Supersonic_Zero()
    else:
        raise ValueError(&#39;Selected fidelity level not supported&#39;)
    aerodynamics.geometry = copy.deepcopy(nexus.vehicle_configurations.base)
    nexus.analyses.base.append(aerodynamics)
    
    nexus.missions = mission_as2.setup(nexus.analyses)
    
    return nexus
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Here we see that &lt;code class=&quot;highlighter-rouge&quot;&gt;nexus.missions&lt;/code&gt; has been updated in addition to &lt;code class=&quot;highlighter-rouge&quot;&gt;nexus.analyses&lt;/code&gt;, since failing to do this would have the mission run with the previous analysis settings.&lt;/p&gt;

&lt;h3 id=&quot;key-functions-in-the-optimizer-setup&quot;&gt;Key Functions in the Optimizer Setup&lt;/h3&gt;

&lt;p&gt;We briefly mentioned how optimization parameters would need to be converted so that they could run with a particular optimizer. Here we show how this is managed and show which functions are likely to be useful in building a new optimizer setup.&lt;/p&gt;

&lt;p&gt;The key items that will be needed for most optimizers are shown below, taken from the PyOpt setup:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;inp = problem.optimization_problem.inputs
obj = problem.optimization_problem.objective
con = problem.optimization_problem.constraints  
   
# Set inputs
nam = inp[:,0] # Names
ini = inp[:,1] # Initials
bnd = inp[:,2] # Bounds
scl = inp[:,3] # Scale
typ = inp[:,4] # Type
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;These can be scaled with two helper functions that are part of the SUAVE distribution:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from SUAVE.Optimization import helper_functions as help_fun

bnd_constraints    = help_fun.scale_const_bnds(con)
scaled_constraints = help_fun.scale_const_values(con,bnd_constraints)
x                  = ini/scl
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;What happens next is entirely dependent on what optimizer you want to use. Some may require that constraint bounds happen at 0 or are either &amp;gt; or &amp;lt;. However this setup is done, you will likely need to create a function that can accept the problem and inputs and give required outputs such as the objective value and constraints. In the PyOpt case, this is done with a simple wrapper and an added function:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mywrap = lambda x:PyOpt_Problem(problem,x)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;…&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def PyOpt_Problem(problem,x):
   
	obj   = problem.objective(x)
	const = problem.all_constraints(x).tolist()
	fail  = np.array(np.isnan(obj.tolist()) or np.isnan(np.array(const).any())).astype(int)

   
	print &#39;Inputs&#39;
	print x
	print &#39;Obj&#39;
	print obj
	print &#39;Con&#39;
	print const
   
	return obj,const,fail
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Please visit our &lt;a href=&quot;/forum&quot;&gt;forum&lt;/a&gt; if you have any other questions on how the optimizer interface works or how to convert the values to what you need.&lt;/p&gt;
</description>
        <pubDate>Thu, 05 Jan 2017 05:25:00 -0800</pubDate>
        <link>http://suavecode.github.io//guides/optimization.html</link>
        <guid isPermaLink="true">http://suavecode.github.io//guides/optimization.html</guid>
        
        
        <category>documentation</category>
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Boeing 737-800</title>
        <description>&lt;link rel=&quot;stylesheet&quot; href=&quot;//cdn.jsdelivr.net/highlight.js/8.6/styles/default.min.css&quot; /&gt;

&lt;script src=&quot;//cdn.jsdelivr.net/highlight.js/8.6/highlight.min.js&quot;&gt;&lt;/script&gt;

&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;

&lt;h2 id=&quot;boeing-737-800-analysis-tutorial&quot;&gt;Boeing 737-800 Analysis Tutorial&lt;/h2&gt;

&lt;p&gt;This tutorial shows how the user can setup a conventional configuration aircraft, a mission the aircraft is to fly, and then simulate the aircraft’s performance over the defined mission. The code is divided into a number of functions that are called from the main function.&lt;/p&gt;

&lt;h3 id=&quot;steps-to-simulate-the-aircrafts-performance-over-a-mission-&quot;&gt;Steps to simulate the aircraft’s performance over a mission :&lt;/h3&gt;

&lt;p&gt;1) Locate the folder where you have the tutorial repository. If using the command line, cd to this directory.&lt;/p&gt;

&lt;p&gt;2) Open the tut_mission_B737.py script in your favorite editor or IDE. The script is setup to run the B737 on its design mission. Run it in your IDE. If using the command line use the command&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt; python tut_mission_B737_800.py  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3) A few plots depicting the variation of the different aircraft performance parameters over the course of the mission are shown.&lt;/p&gt;

&lt;h3 id=&quot;important-functions-&quot;&gt;Important Functions :&lt;/h3&gt;

&lt;p&gt;The script is divided into a set of functions that setup different aspects of the modeling process. The important functions are:&lt;/p&gt;

&lt;h4 id=&quot;vehiclesetup&quot;&gt;vehicle_setup()&lt;/h4&gt;
&lt;p&gt;function is where the aircraft’s geometry is specified.&lt;/p&gt;

&lt;h5 id=&quot;setting-up-a-wing&quot;&gt;Setting up a wing&lt;/h5&gt;
&lt;p&gt;The code below shows how the main wing of the aircraft is set up. The basic geometric inputs that define the wing are specified. Then the wing is then appended to the vehicle, which is an instance of the aircraft class. &lt;/p&gt;

&lt;p&gt;In SUAVE units are identified through the use of a units package called Pint. Notice, that for the wing sweep that the units are specified in degrees through *Units.deg. To get results into a desired unit use /Units.deg.&lt;/p&gt;

&lt;p&gt;The wing sweep is defined as the sweep of the quarter chord. Additionally, a symmetric wing means that it is symmetric about the root, i.e. there is  right and left side.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;
    wing = SUAVE.Components.Wings.Main_Wing()
    wing.tag = &#39;main_wing&#39;
    
    wing.aspect_ratio            = 10.18
    wing.sweeps.quarter_chord    = 25 * Units.deg
    wing.thickness_to_chord      = 0.1
    wing.taper                   = 0.1
    wing.span_efficiency         = 0.9
    wing.spans.projected         = 34.32 * Units.meter
    wing.chords.root             = 7.760 * Units.meter
    wing.chords.tip              = 0.782 * Units.meter
    wing.chords.mean_aerodynamic = 4.235 * Units.meter
    wing.areas.reference         = 124.862 * Units[&#39;meters**2&#39;]  
    wing.twists.root             = 4.0 * Units.degrees
    wing.twists.tip              = 0.0 * Units.degrees
    wing.origin                  = [13.61,0,-1.27] # meters
    wing.vertical                = False
    wing.symmetric               = True
    wing.high_lift               = True
    wing.dynamic_pressure_ratio  = 1.0

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;setting-up-the-fuselage&quot;&gt;Setting up the fuselage&lt;/h5&gt;
&lt;p&gt;Similar to the wing above, the code below illustrates how a fuselage can be added to the vehicle. Again the user is required to specify the basic fuselage geometric parameters and then add the fuselage object to the vehicle.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;  
    fuselage = SUAVE.Components.Fuselages.Fuselage()
    fuselage.tag = &#39;fuselage&#39;
    
    fuselage.number_coach_seats    = vehicle.passengers
    fuselage.seats_abreast         = 6
    fuselage.seat_pitch            = 1     * Units.meter
    fuselage.fineness.nose         = 1.6
    fuselage.fineness.tail         = 2.
    fuselage.lengths.nose          = 6.4   * Units.meter
    fuselage.lengths.tail          = 8.0   * Units.meter
    fuselage.lengths.cabin         = 28.85 * Units.meter
    fuselage.lengths.total         = 38.02 * Units.meter
    fuselage.lengths.fore_space    = 6.    * Units.meter
    fuselage.lengths.aft_space     = 5.    * Units.meter
    fuselage.width                 = 3.74  * Units.meter
    fuselage.heights.maximum       = 3.74  * Units.meter
    fuselage.effective_diameter    = 3.74     * Units.meter
    fuselage.areas.side_projected  = 142.1948 * Units[&#39;meters**2&#39;] 
    fuselage.areas.wetted          = 446.718  * Units[&#39;meters**2&#39;] 
    fuselage.areas.front_projected = 12.57    * Units[&#39;meters**2&#39;] 
    fuselage.differential_pressure = 5.0e4 * Units.pascal # Maximum differential pressure
    
    fuselage.heights.at_quarter_length          = 3.74 * Units.meter
    fuselage.heights.at_three_quarters_length   = 3.65 * Units.meter
    fuselage.heights.at_wing_root_quarter_chord = 3.74 * Units.meter
    
    # add to vehicle
    vehicle.append_component(fuselage)
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;setting-up-the-propulsion-system&quot;&gt;Setting up the propulsion system&lt;/h5&gt;

&lt;p&gt;The aircraft uses a turbofan engine. This engine can be constructed piece by piece using the energy network framework. We instantiate the network as shown below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;
    # ------------------------------------------------------------------
    #   Turbofan Network
    # ------------------------------------------------------------------    
    
    #instantiate the gas turbine network
    turbofan = SUAVE.Components.Energy.Networks.Turbofan()
    turbofan.tag = &#39;turbofan&#39;
    
    # setup
    turbofan.number_of_engines = 2
    turbofan.bypass_ratio      = 5.4
    turbofan.engine_length     = 2.71 * Units.meter
    turbofan.nacelle_diameter  = 2.05 * Units.meter
    turbofan.origin            = [[13.72, 4.86,-1.9],[13.72, -4.86,-1.9]] # meters
    
    #compute engine areas
    turbofan.areas.wetted      = 1.1*np.pi*turbofan.nacelle_diameter*turbofan.engine_length
    
    # working fluid
    turbofan.working_fluid = SUAVE.Attributes.Gases.Air()

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next the components of the turbofan are initialized and added to the engine as shown in the energy networks section. The turbofan is composed of an inlet diffuser (nozzle), low and high pressure compressors, a combustor, a fan, a high and low pressure turbine, and exit nozzles for the core and the fan. &lt;/p&gt;

&lt;p&gt;Finally the network is added to the aircraft as shown below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;
#size the turbofan
turbofan_sizing(turbofan,mach_number,altitude)   
    
# add  gas turbine network turbofan to the vehicle 
vehicle.append_component(turbofan)  

# add  gas turbine network gt_engine to the vehicle
vehicle.append_component(turbofan)  
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;data-structure-visualization&quot;&gt;Data Structure Visualization&lt;/h4&gt;
&lt;p&gt;The data structure associated with the Boeing 737-800 can be visualized &lt;a href=&quot;/guides/data_structures/B737.html&quot;&gt;here&lt;/a&gt;. &lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/guides/data_structures/B737.html&quot;&gt;&lt;img src=&quot;../images/b737_datastructure_preview.png&quot; alt=&quot;Boeing 737 Data Structure&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This visualization shows the hierarchy of data in a SUAVE vehicle. Some of the values are defaulted, for example costs. This is because we are not performing cost analysis on the Boeing 737-800. Additionally, this snapshot of the data structure was taken prior to analysis. Therefore weights have not been calculated and are not part of the data. During the mission analysis component weights will be determined and weights will be populated.&lt;/p&gt;

&lt;h4 id=&quot;configssetup&quot;&gt;configs_setup()&lt;/h4&gt;
&lt;p&gt;The aircraft geometry created is converted into configurations that can be used to make simple modifications to the geometric parameters while not modifying the aircraft geometry completely. An example of the use of this feature is when high-lift devices need to be deployed during landing and takeoff. Thus a landing and takeoff configuration can be added as shown below and then during say the flaps and slats settings can be set differently for each of the configurations.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;
    # ------------------------------------------------------------------
    #   Cruise Configuration
    # ------------------------------------------------------------------
    config = SUAVE.Components.Configs.Config(base_config)
    config.tag = &#39;cruise&#39;
    configs.append(config)

    # ------------------------------------------------------------------
    #   Takeoff Configuration
    # ------------------------------------------------------------------
    config = SUAVE.Components.Configs.Config(base_config)
    config.tag = &#39;takeoff&#39;
    config.wings[&#39;main_wing&#39;].flaps.angle = 20. * Units.deg
    config.wings[&#39;main_wing&#39;].slats.angle = 25. * Units.deg
    config.max_lift_coefficient_factor    = 1.

    configs.append(config)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;missionsetup&quot;&gt;mission_setup()&lt;/h4&gt;
&lt;p&gt;To modify the baseline mission that the aircraft flies, go to the mission_setup() function and add or delete segments of the mission&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;
    segment = Segments.Cruise.Constant_Speed_Constant_Altitude(base_segment)
    segment.tag = &quot;cruise&quot;

    segment.analyses.extend( analyses.cruise )

    segment.air_speed  = 230.412 * Units[&#39;m/s&#39;]
    segment.distance   = 2490. * Units.nautical_miles

    # add to mission
    mission.append_segment(segment)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;baseanalysis&quot;&gt;base_analysis()&lt;/h4&gt;
&lt;p&gt;Also to leverage SUAVE’s multifidelity capability and use a different fidelity analysis for any of the disciplines (aerodynamics,propulsion, stability, etc), the base_analysis function can be modified by switching out an analysis module for a different one.&lt;/p&gt;

&lt;h3 id=&quot;other-functions-&quot;&gt;Other Functions :&lt;/h3&gt;

&lt;h4 id=&quot;main&quot;&gt;main()&lt;/h4&gt;

&lt;p&gt;The main function is the driver function for the mission simulation. It calls the various routines in the appropriate order in order to set up the geometry and the mission, evaluate the performance of the aircraft over the mission and return the results.&lt;/p&gt;

&lt;h4 id=&quot;fullsetup&quot;&gt;full_setup()&lt;/h4&gt;

&lt;p&gt;This function (called from the main() function) sets up the aircraft geometry, configs and the missions the aircraft is to be analysed for by calling the vehicle_setup, configs_setup, analyses_setup, mission_setup and missions_setup functions.&lt;/p&gt;

&lt;h4 id=&quot;simplesizing&quot;&gt;simple_sizing()&lt;/h4&gt;

&lt;p&gt;The simple sizing function sizes the aircraft’s geometric components based on the geometric inputs specified by the user in the vehicle_setup() function.&lt;/p&gt;

&lt;h4 id=&quot;baseanalysis-1&quot;&gt;base_analysis()&lt;/h4&gt;

&lt;p&gt;The method takes in the vehicle and assigns different analysis methods (for aero, propulsion, weights, stability) to the analyses object.&lt;/p&gt;

&lt;h4 id=&quot;analysessetup&quot;&gt;analyses_setup()&lt;/h4&gt;

&lt;p&gt;This functions takes in the base analysis and sets up different analysis methods for different configurations.&lt;/p&gt;

&lt;h4 id=&quot;missionssetup&quot;&gt;missions_setup()&lt;/h4&gt;

&lt;p&gt;This method allows the user to set up a variety of missions that need to be evaluated for an aircraft.&lt;/p&gt;

&lt;h4 id=&quot;plotmission&quot;&gt;plot_mission()&lt;/h4&gt;

&lt;p&gt;This is a post processing function that takes in the results data structure and generates the necessary plots.&lt;/p&gt;

&lt;h3 id=&quot;results&quot;&gt;RESULTS&lt;/h3&gt;

&lt;p&gt;The plots shown below should be generated if the mission analysis executes correctly. The results show the aerodynamic, propulsion and mission properties of the B737-800 for the defined mission.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/B737_mission.png&quot; alt=&quot;B737 mission&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/B737_aero.png&quot; alt=&quot;B737 Aerodynamics&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/B737_engine.png&quot; alt=&quot;B737 Propulsion&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/B737_drag.png&quot; alt=&quot;B737 Drag&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;modifying-the-aircrafts-geometry-or-mission-&quot;&gt;Modifying the Aircraft’s Geometry or Mission :&lt;/h3&gt;

&lt;p&gt;Suppose we want to simulate a high span variant of the B737-800. The span is increased to 40.0 m. We assume the wing chords, sweep, taper ratio, thickness to chord ratio remain the same. Thus changing the span only changes the aspect ratio and the wing area.&lt;/p&gt;

&lt;p&gt;Now we try to fly the aircraft at a lower cruise speed  of 200m/s at a cruise altitude of 25000 ft&lt;/p&gt;

&lt;p&gt;1) To update the geometry, scroll to the vehicle_setup() function&lt;/p&gt;

&lt;p&gt;2) Modify the parameters of the main wing&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;
wing.aspect_ratio            = 10.12      
wing.spans.projected         = 40.0  * Units.meter
wing.areas.reference         = 158.0 * Units[&#39;meters**2&#39;] 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You may also need to update the reference area for the aircraft.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;vehicle.reference_area         =     158.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3) Update the mission parameters by moving to the mission_setup() function&lt;/p&gt;

&lt;p&gt;4) First update the end altitude of the final climb segment. Although the original script has the altitude stated in m, courtesy of the Units package it is easy to modify the altitude to 25,000ft without worrying about the units conversion as shown below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;segment = Segments.Climb.Constant_Speed_Constant_Rate(base_segment)
segment.tag = &quot;climb_3&quot;

segment.analyses.extend( analyses.cruise )

segment.altitude_end = 25000 * Units.ft  
segment.air_speed    = 226.0  * Units[&#39;m/s&#39;]
segment.climb_rate   = 3.0    * Units[&#39;m/s&#39;]

mission.append_segment(segment)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5) Next update the cruise segment velocity to  the new speed value  &lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;segment = Segments.Cruise.Constant_Speed_Constant_Altitude(base_segment)
segment.tag = &quot;cruise&quot;

segment.analyses.extend( analyses.cruise )

segment.air_speed  = 200.0 * Units[&#39;m/s&#39;]
segment.distance   = 2490. * Units.nautical_miles

# add to mission
mission.append_segment(segment)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6) Now go back and run the mission for the updated geometry and mission using the steps specified in ‘Steps to run the aircraft on a mission’&lt;/p&gt;

</description>
        <pubDate>Sun, 14 Feb 2016 05:25:00 -0800</pubDate>
        <link>http://suavecode.github.io//guides/boeing_737-800.html</link>
        <guid isPermaLink="true">http://suavecode.github.io//guides/boeing_737-800.html</guid>
        
        
        <category>guides</category>
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Concorde</title>
        <description>&lt;link rel=&quot;stylesheet&quot; href=&quot;//cdn.jsdelivr.net/highlight.js/8.6/styles/default.min.css&quot; /&gt;

&lt;script src=&quot;//cdn.jsdelivr.net/highlight.js/8.6/highlight.min.js&quot;&gt;&lt;/script&gt;

&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;

&lt;h2 id=&quot;concorde-tutorial&quot;&gt;Concorde Tutorial&lt;/h2&gt;

&lt;p&gt;This tutorial gives an overview of changes made to the setup to evaluate a supersonic mission.&lt;/p&gt;

&lt;h3 id=&quot;aerodynamics-module&quot;&gt;Aerodynamics Module:&lt;/h3&gt;

&lt;p&gt;To allow aerodynamic calculations in supersonic flight, we use the zero fidelity supersonic module. This is quite easy to swap with the subsonic zero fidelity model. This model and the zero fidelity subsonic module are in the same directory, so they can be switched by changing a single line in the analysis section:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
aerodynamics = SUAVE.Analyses.Aerodynamics.Fidelity_Zero()
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;to&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
aerodynamics = SUAVE.Analyses.Aerodynamics.Supersonic_Zero()
&lt;/code&gt;
The supersonic aerodynamics module can still handle the subsonic portions of the flight.&lt;/p&gt;

&lt;h3 id=&quot;wing-additions&quot;&gt;Wing Additions:&lt;/h3&gt;

&lt;p&gt;Some of the calculations are changed to account for different properties that are not automatically captured in the model.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Vortex lift is set to true. This causes the vortex lift module to add a CL increment to the aircraft.&lt;/li&gt;
  &lt;li&gt;High Mach is set to true. This changes the way that high subsonic compressibility drag is calculated and brings it more in line with Concorde behavior.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
    wing.vortex_lift             = True
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
    wing.high_mach               = True
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Note also that Concorde does not have a horizontal tail, so this is not included in the vehicle setup.&lt;/p&gt;

&lt;h3 id=&quot;turbojet-module&quot;&gt;Turbojet Module:&lt;/h3&gt;

&lt;p&gt;Since Concorde has a diverging nozzle that allows for supersonic outflow, a modified turbojet is used that can account for this. This turbojet component is again switched out with a single line.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
nozzle = SUAVE.Components.Energy.Converters.Supersonic_Nozzle()
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;instead of &lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
nozzle = SUAVE.Components.Energy.Converters.Expansion_Nozzle()  
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;mission-segments&quot;&gt;Mission Segments:&lt;/h3&gt;

&lt;p&gt;The mission typically flown by Concorde calls for mission segments that are not utilized in the Boeing 737 case. These are Mach number dependent, and require different inputs from the segments previously given. The new mission segments are linear Mach constant rate (climb and descent). Both require a starting and ending Mach number, which will vary linearly in time over the descent. For an example, check the third climb segment:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;segment = Segments.Climb.Linear_Mach_Constant_Rate(base_segment)
segment.tag = &quot;climb_3&quot;

segment.analyses.extend( analyses.cruise )

segment.altitude_end = 7.60   * Units.km
segment.mach_start   = 0.64
segment.mach_end     = 1.0
segment.climb_rate   = 5.05  * Units[&#39;m/s&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;takeoff-and-landing-configuration&quot;&gt;Takeoff and Landing Configuration&lt;/h3&gt;

&lt;p&gt;Since Concorde does not have flaps or slats, specific takeoff and landing configurations are not used.&lt;/p&gt;
</description>
        <pubDate>Wed, 15 Jul 2015 07:25:00 -0700</pubDate>
        <link>http://suavecode.github.io//guides/concorde.html</link>
        <guid isPermaLink="true">http://suavecode.github.io//guides/concorde.html</guid>
        
        
        <category>guides</category>
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Solar UAV</title>
        <description>&lt;link rel=&quot;stylesheet&quot; href=&quot;//cdn.jsdelivr.net/highlight.js/8.6/styles/default.min.css&quot; /&gt;

&lt;script src=&quot;//cdn.jsdelivr.net/highlight.js/8.6/highlight.min.js&quot;&gt;&lt;/script&gt;

&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;

&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;The purpose of this tutorial is to educate users on how to setup a preconfigured solar energy network to work with a high altitude solar UAV. In this tutorial it is assumed that the user has some familiarity with SUAVE having completed the fundamental tutorial for the Boeing 737-800.  You will learn about setting up the following:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Solar missions,&lt;/li&gt;
  &lt;li&gt;Human powered/solar weight estimation,&lt;/li&gt;
  &lt;li&gt;Boundary layer transition&lt;/li&gt;
  &lt;li&gt;Solar panels, &lt;/li&gt;
  &lt;li&gt;Batteries,&lt;/li&gt;
  &lt;li&gt;Electric motors, &lt;/li&gt;
  &lt;li&gt;Propellers,&lt;/li&gt;
  &lt;li&gt;Electric network integration in a solar UAV&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Because of the flexible nature of SUAVE, the approach shown is just one way to setup the UAV for analysis. By experimenting and eventually developing your own code you will be able to do far more than what is shown in this tutorial. The original script can be found in the tutorial repository as tut_solar_uav.py.&lt;/p&gt;

&lt;h2 id=&quot;vehicle-and-mission&quot;&gt;Vehicle and Mission&lt;/h2&gt;

&lt;p&gt;The vehicle is similar to the Qinetiq Zephyr but far larger at 40 meters in wing span and a weight of 200 kg. However, it does carry double the payload of the Zephyr at 5 kg and accounts for constant payload power usage. The battery energy density is set to an optimistic estimate of 450 Watt-hours per kg. Additionally, 90 percent of the wings are covered with solar panels that have a 25 percent efficiency.&lt;/p&gt;

&lt;p&gt;This mission exercises the methods developed for solar radiation estimation, propeller and motor integration, as well as the human powered aircraft weight estimation. The mission setup is a constant altitude cruise at 15 km at Mach 0.12 for about 24 hours. The location is over the California Bay Area during the summer solstice.&lt;/p&gt;

&lt;h2 id=&quot;setup&quot;&gt;Setup&lt;/h2&gt;

&lt;p&gt;This tutorial highlights the differences between setting up a typical aircraft like a Boeing 737 and a solar UAV.&lt;/p&gt;

&lt;h3 id=&quot;mission-setup&quot;&gt;Mission Setup&lt;/h3&gt;

&lt;p&gt;For a solar UAV, the starting location as well as the day and time are critical. So the first segment must be modified to include this information. It is important to note that the start times provided are in “Zulu” time or Greenwich Mean Time. This is typical for aircraft navigation to prevent time zone errors and ambiguity.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;segment.state.numerics.number_control_points = 64
segment.start_time                           = time.strptime(&quot;Tue, Jun 21 11:30:00  2015&quot;, &quot;%a, %b %d %H:%M:%S %Y&quot;,)
segment.altitude                             = 15.0  * Units.km 
segment.mach                                 = 0.12
segment.distance                             = 3050.0 * Units.km
segment.battery_energy                       = vehicle.propulsors.network.battery.max_energy*0.2 #Set the battery charge to start
segment.latitude                             = 37.4300
segment.longitude                            = -122.1700
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Additionally, this mission is highly simplified. It consists of only one mission segment. To provide ample resolution the number of control points have been increased to 64.&lt;/p&gt;

&lt;h3 id=&quot;structural-weight-sizing&quot;&gt;Structural Weight Sizing&lt;/h3&gt;

&lt;p&gt;The vehicle sizing of the human powered aircraft or solar UAV requires the dimensions of the vehicle like in other weight estimation methods. However, it also requires information about the number of wing ribs and the number of end ribs. The end ribs are relevant for wing designs where the sections can come apart for transportation.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;wing.number_ribs             = 26.
wing.number_end_ribs         = 2.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;wing-boundary-layer-transition&quot;&gt;Wing Boundary Layer Transition&lt;/h3&gt;

&lt;p&gt;The transition location of the boundary layer can have a great impact on the drag of the wing. This is especially important in properly designed low Reynolds number flows when laminar flow can be extended for larger percentages of the surface. The code snippet below is how surfaces have transition points set. These are estimates provided from the designer based on experience.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;wing.transition_x_upper      = 0.6
wing.transition_x_lower      = 1.0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;solar-panels&quot;&gt;Solar Panels&lt;/h3&gt;

&lt;p&gt;The solar panel model is quite simple and only requires a capture area, an efficiency, and mass. In this case we assume that 90% of the wing area is covered in solar panels.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;panel.area                 = vehicle.reference_area * 0.9
panel.efficiency           = 0.25
panel.mass_properties.mass = panel.area*(0.60 * Units.kg)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;batteries&quot;&gt;Batteries&lt;/h3&gt;

&lt;p&gt;The batteries are set up with knowledge of the mass of the battery and the specific energy. In this case a futuristic specific energy of 450 Watt-hr/kg is set for lithium ion type batteries. The resistance of the batteries is another important input to determine charging and discharging losses.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;bat = SUAVE.Components.Energy.Storages.Batteries.Constant_Mass.Lithium_Ion()
bat.mass_properties.mass = 55.0 * Units.kg
bat.specific_energy      = 450.*Units.Wh/Units.kg
bat.resistance           = 0.05
initialize_from_mass(bat,bat.mass_properties.mass)
net.battery              = bat
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;propeller&quot;&gt;Propeller&lt;/h3&gt;

&lt;p&gt;To setup the propeller we will actually design an optimized propeller. This is done through the methods provided by Adkins and Liebeck. The attributes of the propeller design are then seeded to the motor and network to accelerate convergence of the propeller and motor models.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;prop_attributes = Data()
prop_attributes.number_blades       = 2.0
prop_attributes.freestream_velocity = 40.0 # freestream m/s
prop_attributes.angular_velocity    = 150. * Units[&#39;rpm&#39;]
prop_attributes.tip_radius          = 4.25
prop_attributes.hub_radius          = 0.05
prop_attributes.design_Cl           = 0.7
prop_attributes.design_altitude     = 14.0 * Units.km
prop_attributes.design_thrust       = 0.0
prop_attributes.design_power        = 3500.0
prop_attributes                     = propeller_design(prop_attributes)

prop = SUAVE.Components.Energy.Converters.Propeller()
prop.prop_attributes = prop_attributes
net.propeller        = prop
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;motor&quot;&gt;Motor&lt;/h3&gt;

&lt;p&gt;This motor model relies on data that is generally available from motor manufacturers. This includes the resistance, no load current, and the speed constant. Additionally, any gearbox is specified here and basic information about the propeller is entered here to help inform the solver when converging the motor and propeller analyses.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;motor = SUAVE.Components.Energy.Converters.Motor()
motor.resistance           = 0.008
motor.no_load_current      = 4.5
motor.speed_constant       = 120. * Units[&#39;rpm&#39;] # RPM/volt converted to (rad/s)/volt      
motor.propeller_radius     = prop.prop_attributes.tip_radius
motor.propeller_Cp         = prop.prop_attributes.Cp
motor.gear_ratio           = 12. # Gear ratio
motor.gearbox_efficiency   = .98 # Gear box efficiency
motor.expected_current     = 160. # Expected current
motor.mass_properties.mass = 2.0
net.motor                  = motor   
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;running&quot;&gt;Running&lt;/h2&gt;

&lt;p&gt;As you should be familiar with by now, running this script is just like any other.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;python tut_solar_uav.py
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;results&quot;&gt;Results&lt;/h2&gt;

&lt;p&gt;If all went well the script ran and it provided you with more plots than you ever wanted. Here are some of the plots that were generated when we ran it:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/solar_flux.png&quot; alt=&quot;solar_flux&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/battery_charging.png&quot; alt=&quot;battery charging&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/battery_energy.png&quot; alt=&quot;battery energy&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Thu, 18 Jun 2015 16:22:20 -0700</pubDate>
        <link>http://suavecode.github.io//guides/solar_uav.html</link>
        <guid isPermaLink="true">http://suavecode.github.io//guides/solar_uav.html</guid>
        
        
        <category>guides</category>
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Payload Range Diagram</title>
        <description>&lt;h3 id=&quot;embraer-e-190-payload-range-diagram-tutorial&quot;&gt;Embraer E-190 Payload Range Diagram Tutorial&lt;/h3&gt;
&lt;p&gt;1) Locate the tutorial script folder.&lt;/p&gt;

&lt;p&gt;2) Open the test_payload_range.py script in your favorite editor or IDE.&lt;/p&gt;

&lt;p&gt;3) Similar to the B737-800 Tutorial, the setup is divided into steps.&lt;/p&gt;

&lt;p&gt;4) For the Payload Range Diagram, besides the vehicle and mission, the user must provide the following inputs:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;cruise_segment_tag&lt;/strong&gt;: You must enter the tag of the segment which will have its length modified in order to comply with required fuel burn for each one of the payload range diagram points.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;reserves&lt;/strong&gt;: This will be considered as a fixed fuel reserve for all the diagram points.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;5) The tutorial presents the following definition:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# run payload diagram	
cruise_segment_tag = &quot;Cruise&quot;
reserves = 1750.
payload_range_results = payload_range(vehicle,mission,cruise_segment_tag,reserves)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;6) First, let’s just run it as it is for now. Run the script in either the IDE or in a terminal as &lt;code class=&quot;highlighter-rouge&quot;&gt;python tut_payload_range.py&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;7) After the calculations are completed, the payload diagram will be plotted and the data will be stored in a file named ‘PayloadRangeDiagram.dat’. This is in the folder where you run the script.&lt;/p&gt;

&lt;p&gt;8) You can try to modify vehicle and/or mission parameters and see how the payload range diagram is affected. For now, let’s add some drag counts to the airplane:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Locate and open the script test_mission_Embraer_E190_constThr.py, in the tutorial folder (this is the script that contains the vehicle and mission setups)&lt;/li&gt;
  &lt;li&gt;Locate &lt;code class=&quot;highlighter-rouge&quot;&gt;base_analysis()&lt;/code&gt; and then the Aerodynamics Analysis text block (line 113) &lt;/li&gt;
  &lt;li&gt;Add 50 drag counts to the vehicle (line 115): &lt;code class=&quot;highlighter-rouge&quot;&gt;aerodynamics.settings.drag_coefficient_increment = 0.0050 &lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Rerun the script as before and notice the changes in the results.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;9) Similarly the mission parameters can be changed. Again, this lets the user decide what changes they want to explore.&lt;/p&gt;

</description>
        <pubDate>Wed, 17 Jun 2015 16:22:21 -0700</pubDate>
        <link>http://suavecode.github.io//guides/payload_range_diagram.html</link>
        <guid isPermaLink="true">http://suavecode.github.io//guides/payload_range_diagram.html</guid>
        
        
        <category>guides</category>
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Turbofan Network</title>
        <description>&lt;link rel=&quot;stylesheet&quot; href=&quot;//cdn.jsdelivr.net/highlight.js/8.6/styles/default.min.css&quot; /&gt;

&lt;script src=&quot;//cdn.jsdelivr.net/highlight.js/8.6/highlight.min.js&quot;&gt;&lt;/script&gt;

&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;

&lt;h2 id=&quot;turbofan-modeling-tutorial&quot;&gt;Turbofan Modeling Tutorial&lt;/h2&gt;

&lt;p&gt;This tutorial describes how the energy network framework in SUAVE can be used to build a model of a turbofan engine. Once this is clear to the user, understanding the setup of the other gasturbine models, the ducted fan and the turbojet will be much easier. The turbofan model is built with several turbofan components as its building blocks. These are then linked together through their inputs and outputs. The script to follow is the tut_mission_B737.py script that was used in the &lt;a href=&quot;/guides/boeing_737-800.html&quot;&gt;Boeing 737-800 Analysis Tutorial&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;setting-up-the-turbofan-model&quot;&gt;Setting up the Turbofan model&lt;/h3&gt;

&lt;p&gt;First the turbofan energy network is instantiated. The parameters associated with the network as a whole are assigned.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;# ------------------------------------------------------------------
#   Turbofan Network
# ------------------------------------------------------------------    

#instantiate the gas turbine network
turbofan = SUAVE.Components.Energy.Networks.Turbofan()
turbofan.tag = &#39;turbofan&#39;

# setup
turbofan.bypass_ratio      = 5.4
turbofan.number_of_engines = 2.0
turbofan.engine_length     = 2.5
turbofan.nacelle_diameter  = 1.580

# working fluid
turbofan.working_fluid = SUAVE.Attributes.Gases.Air()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then the different components are added&lt;/p&gt;

&lt;h3 id=&quot;components&quot;&gt;Components&lt;/h3&gt;

&lt;p&gt;The basic components used to model the turbofan are described below.&lt;/p&gt;

&lt;h4 id=&quot;ram&quot;&gt;Ram&lt;/h4&gt;

&lt;p&gt;The ‘Ram’ component is used to convert the freestream quantities that are passed into the turbofan network into stagnation quantities. As the turbofan network is based on a 1D gasdynamic analysis, most of the energy transfer across the different components are modelled as changes in the stagnation quantities. Thus the Ram component acts as a preprocessor converting the input conditions into quantities required by the network.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;# ------------------------------------------------------------------
#   Component 1 - Ram

# to convert freestream static to stagnation quantities

# instantiate
ram = SUAVE.Components.Energy.Converters.Ram()
ram.tag = &#39;ram&#39;

# add to the network
turbofan.append(ram)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;nozzle&quot;&gt;Nozzle&lt;/h4&gt;

&lt;p&gt;The ‘Nozzle’ component is used to model the inlet diffuser, the outlet fan, and the compressor nozzles as shown below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;# ------------------------------------------------------------------
#  Component 2 - Inlet Nozzle

# instantiate
inlet_nozzle = SUAVE.Components.Energy.Converters.Compression_Nozzle()
inlet_nozzle.tag = &#39;inlet_nozzle&#39;

# setup
inlet_nozzle.polytropic_efficiency = 0.98
inlet_nozzle.pressure_ratio        = 0.98

# add to network
turbofan.append(inlet_nozzle)

# ------------------------------------------------------------------
#  Component 8 - Core Nozzle

# instantiate
nozzle = SUAVE.Components.Energy.Converters.Expansion_Nozzle()   
nozzle.tag = &#39;core_nozzle&#39;

# setup
nozzle.polytropic_efficiency = 0.95
nozzle.pressure_ratio        = 0.99    

# add to network
turbofan.append(nozzle)

# ------------------------------------------------------------------
#  Component 9 - Fan Nozzle

# instantiate
nozzle = SUAVE.Components.Energy.Converters.Expansion_Nozzle()   
nozzle.tag = &#39;fan_nozzle&#39;

# setup
nozzle.polytropic_efficiency = 0.95
nozzle.pressure_ratio        = 0.99    

# add to network
turbofan.append(nozzle)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;compressor&quot;&gt;Compressor&lt;/h4&gt;

&lt;p&gt;Two compressors are used in the turbofan model, a low and a high pressure compressor.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;# ------------------------------------------------------------------
#  Component 3 - Low Pressure Compressor

# instantiate 
compressor = SUAVE.Components.Energy.Converters.Compressor()    
compressor.tag = &#39;low_pressure_compressor&#39;

# setup
compressor.polytropic_efficiency = 0.91
compressor.pressure_ratio        = 1.14    

# add to network
turbofan.append(compressor)

# ------------------------------------------------------------------
#  Component 4 - High Pressure Compressor

# instantiate
compressor = SUAVE.Components.Energy.Converters.Compressor()    
compressor.tag = &#39;high_pressure_compressor&#39;

# setup
compressor.polytropic_efficiency = 0.91
compressor.pressure_ratio        = 13.415    

# add to network
turbofan.append(compressor)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;fan&quot;&gt;Fan&lt;/h4&gt;

&lt;p&gt;A fan component is also added to the network. If you were to model a turbojet, the fan component and the fan nozzle would not be added but all the other components would remain the same.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;# ------------------------------------------------------------------
#  Component 10 - Fan

# instantiate
fan = SUAVE.Components.Energy.Converters.Fan()   
fan.tag = &#39;fan&#39;

# setup
fan.polytropic_efficiency = 0.93
fan.pressure_ratio        = 1.7    

# add to network
turbofan.append(fan)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;combustor&quot;&gt;Combustor&lt;/h4&gt;

&lt;p&gt;The combustor component is where the the fuel to air ratio is computed. It is also used to compute the sfc and the thrust later in the network.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;# ------------------------------------------------------------------
#  Component 7 - Combustor

# instantiate    
combustor = SUAVE.Components.Energy.Converters.Combustor()   
combustor.tag = &#39;combustor&#39;

# setup
combustor.efficiency                = 0.99 
combustor.turbine_inlet_temperature = 1450
combustor.pressure_ratio            = 0.95
combustor.fuel_data                 = SUAVE.Attributes.Propellants.Jet_A()    

# add to network
turbofan.append(combustor)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;turbine&quot;&gt;Turbine&lt;/h4&gt;

&lt;p&gt;The work done by the fan and the compressors is used to compute the turbine work required. This is used to compute the change in the stagnation quantities across the turbine.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;# ------------------------------------------------------------------
#  Component 5 - Low Pressure Turbine

# instantiate
turbine = SUAVE.Components.Energy.Converters.Turbine()   
turbine.tag=&#39;low_pressure_turbine&#39;

# setup
turbine.mechanical_efficiency = 0.99
turbine.polytropic_efficiency = 0.93     

# add to network
turbofan.append(turbine)

# ------------------------------------------------------------------
#  Component 6 - High Pressure Turbine

# instantiate
turbine = SUAVE.Components.Energy.Converters.Turbine()   
turbine.tag=&#39;high_pressure_turbine&#39;

# setup
turbine.mechanical_efficiency = 0.99
turbine.polytropic_efficiency = 0.93     

# add to network
turbofan.append(turbine)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;thrust&quot;&gt;Thrust&lt;/h4&gt;

&lt;p&gt;The thrust component takes in the initial (inputs of the inlet nozzle) and final (exit of the fan and core exirt nozzles) stagnation quantities of the network and the fuel to air ratio and computes the specific fuel conspumption (sfc) and thrust generated by the network (turbofan engine).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;# ------------------------------------------------------------------
#  Component 10 - Thrust

# to compute thrust

# instantiate
thrust = SUAVE.Components.Energy.Processes.Thrust()       
thrust.tag =&#39;thrust&#39;

# setup
thrust.total_design =42383.01

# add to network
turbofan.thrust = thrust   
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;sizing-the-turbofan&quot;&gt;Sizing the Turbofan&lt;/h3&gt;

&lt;p&gt;Once the network is built, it is essential to size the engine with a set of sizing conditions. The sizing function ‘turbofan_sizing’ takes in the model of the turbofan and the mach number and the altitude for which the turbofan is sized. The sizing thrust is an engine/network property (defined in the ‘Setting up the Turbofan model’ section above). The function takes these quantities and computes the design mass flow rate through the components. Once sized, the network/engine can be added to the vehicle as shown in the  B737 tutorial.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#bypass ratio  closer to fan

#design sizing conditions
altitude      = 35000.0*Units.ft
mach_number   = 0.78 
isa_deviation = 0.

# add to network
turbofan.thrust = thrust

#size the turbofan (for thrust)
turbofan_sizing(turbofan,mach_number,altitude)   

#compute the turbofan diameter and engine length
#note that the second input is to maintain a common interface with other sizing methods
compute_turbofan_geometry(turbofan,None)
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Mon, 15 Jun 2015 07:20:03 -0700</pubDate>
        <link>http://suavecode.github.io//guides/turbofan_network.html</link>
        <guid isPermaLink="true">http://suavecode.github.io//guides/turbofan_network.html</guid>
        
        
        <category>guides</category>
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Regional Jet Optimization</title>
        <description>&lt;link rel=&quot;stylesheet&quot; href=&quot;//cdn.jsdelivr.net/highlight.js/8.6/styles/default.min.css&quot; /&gt;

&lt;script src=&quot;//cdn.jsdelivr.net/highlight.js/8.6/highlight.min.js&quot;&gt;&lt;/script&gt;

&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;

&lt;h3 id=&quot;regional-jet-optimization-tutorial&quot;&gt;Regional Jet Optimization Tutorial&lt;/h3&gt;
&lt;p&gt;This tutorial assumes familiarity with SUAVE and knowledge of the information in the Boeing 737-800 analysis tutorial. It provides a specific case of the more general information provided in the optimization structure tutorial, and some more information on how to modify the code for different uses.&lt;/p&gt;

&lt;p&gt;Some important files for the optimization problem can be seen below&lt;/p&gt;

&lt;h3 id=&quot;important-files-&quot;&gt;Important Files :&lt;/h3&gt;

&lt;h4 id=&quot;optimizepy&quot;&gt;Optimize.py:&lt;/h4&gt;
&lt;p&gt;Defines the optimization framework of the problem, wherein one minimizes an assigned objective, subject to certain constraints, by altering some design variables.&lt;/p&gt;

&lt;p&gt;In order to ensure that the subfunctions can communicate with eachother, and that SUAVE can communicate with the external optimizer, a special data object called the “Nexus” is used. The nexus object contains all of the vehicles, missions, results, and other important information. It alters these values at each optimizer iteration, depending on the input parameters defined in Optimize.py.&lt;/p&gt;

&lt;p&gt;In this particular setup, there are two design variables: wing area and cruise altitude. The objective is fuel burn, and there is only one constraint: fuel margin. The default inputs are defined in the following lines.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# [ tag, initial, (lb,ub), scaling, units]
problem.inputs = np.array([
	[ &#39;wing_area&#39;      ,  95., ( 90., 130.), 100., Units.meter**2],
	[ &#39;cruise_altitude&#39;,  11., (  9.,  14.),  10., Units.km      ],
])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Each input parameter takes in 5 values; a tag (an identification to communicate between the optimizer and SUAVE), an initial value, set of bounds, a scale factor (many optimizers tend to be more effective when the input values are of order 1), as well as the units used.&lt;/p&gt;

&lt;p&gt;The objective and constraints are defined in the lines below.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# [ tag, scaling, units ]
problem.objective = np.array([
	[ &#39;fuel_burn&#39;, 10000, Units.kg ]
])

# [ tag, sense, edge, scaling, units ]
problem.constraints = np.array([
	[ &#39;design_range_fuel_margin&#39; , &#39;&amp;gt;&#39;, 0., 1E-1, Units.less],
])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Note that in this case, only a single constraint is used; Multiple constraints may be used using a list format, similar to the input variables.&lt;/p&gt;

&lt;p&gt;This file also defines the “aliasing,” i.e. how the design variables, constraints, and objective map to the variables used in Procedure.py (which is where the problem is evaluated). The aliases for this problem are defined in the lines below.  Note that the first entry refers to the tag defined in either problem.inputs, problem.objective, or problem.constraints.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;problem.aliases = [
	[ &#39;wing_area&#39;                        ,   [&#39;vehicle_configurations.*.wings.main_wing.areas.reference&#39;,
	                                          &#39;vehicle_configurations.*.reference_area&#39;                    ]],  
	[ &#39;cruise_altitude&#39;                  ,    &#39;missions.base.segments.climb_5.altitude_end&#39;                 ],
	[ &#39;fuel_burn&#39;                        ,    &#39;summary.base_mission_fuelburn&#39;                               ],
	[ &#39;design_range_fuel_margin&#39;         ,    &#39;summary.max_zero_fuel_margin&#39;                                ],
]    
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Note that, sometimes, a single input can map to multiple outputs, such as the “wing_area” design variable; in this case, use a list for the outputs, as seen above. The use of a wild card “*”, can also allow values to map to multiple outputs. Values to be outputted cannot contain wild cards as that would be ambiguous to an optimizer.&lt;/p&gt;

&lt;h4 id=&quot;procedurepy&quot;&gt;Procedure.py:&lt;/h4&gt;
&lt;p&gt;This links everything together by defining the steps you would use to size and analyze the aircraft at each optimizer iteration.&lt;/p&gt;

&lt;p&gt;This file contains a number of subfunctions to alter the vehicle and mission. The function setup() instantiates the procedure, defining the functions that are called at each step of the optimizer in their order of execution.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;simple_sizing() defines the geometry of the aircraft based on the input parameters (in this case, wing area and cruise altitude).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;weights() determines the weight breakdown of the aircraft&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;mission() decides which missions are run at each step, as well as the design mission of the aircraft&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;post_process() handles the results from the missions, saving the constraints and objective value&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Each step of the procedure takes the nexus object as an input, and returns the object as an output, ensuring that the data is available for handling.&lt;/p&gt;

&lt;h4 id=&quot;vehiclespy&quot;&gt;Vehicles.py:&lt;/h4&gt;
&lt;p&gt;Initializes the vehicle (or vehicles if desired) used in the optimization problem. This includes two subfunctions: base_setup(), where the vehicle structure is itself defined, including the fuselage, wing, vertical and horizontal tails, and the propulsion system.&lt;/p&gt;

&lt;p&gt;configs_setup() takes in the vehicle that was defined in base_setup() and defines other configurations (such as takeoff and landing, which include different flap settings). This may be used to define other parameters, such as changing the sweep angle of a variable-sweep-wing at higher Mach Numbers, or changing a propulsion component.&lt;/p&gt;

&lt;h4 id=&quot;missionspy&quot;&gt;Missions.py:&lt;/h4&gt;
&lt;p&gt;Initializes the missions that are run at each iteration. In this case, only a single mission is run.&lt;/p&gt;

&lt;h4 id=&quot;analysespy&quot;&gt;Analyses.py:&lt;/h4&gt;
&lt;p&gt;Defines the set of features that are used in this particular problem (e.g. weights correlations, aerodynamics correlations, etc.).&lt;/p&gt;

&lt;h4 id=&quot;plotmissionpy&quot;&gt;Plot_Mission.py:&lt;/h4&gt;
&lt;p&gt;Plots the mission outputs.&lt;/p&gt;

&lt;h3 id=&quot;running-the-problem&quot;&gt;Running the Problem:&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Locate the tutorial script folder “Regional_Jet_Optimization.”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Open the Optimize.py script in a text editor or IDE. You will see this line near the top of main():&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;output = problem.objective()&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;This runs the problem with the default inputs. Run the file using an IDE or type &lt;code class=&quot;highlighter-rouge&quot;&gt;python Optimize.py&lt;/code&gt; in the command line. You should see a set of output plots.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;running-a-sweep-of-the-inputs&quot;&gt;Running a Sweep of the Inputs&lt;/h3&gt;
&lt;p&gt;Now try running a 2D sweep of the problem to observe the shape of the design space: comment &lt;code class=&quot;highlighter-rouge&quot;&gt;output = problem.objective&lt;/code&gt; then uncomment the following (the next line down in the code).&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;variable_sweep(problem)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Then run the program again. This could take a few minutes. The results should look like the plot below.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/wing_area_v_cruise_altitude_v_fuel_burn_5_steps.png&quot; alt=&quot;2D Sweep&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The labeled lines depict the fuel margin (i.e. fraction of the aircraft remaining weight that can be loaded with fuel). Positive values indicate a feasible design. Fuel burn is shown in the colored contours. Note that a smoother plot may be created by changing the number of points in the sweep function, but this will take more time. A carpet plot run using 400 points on can be seen below. A local minimum is now visible.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/wing_area_v_cruise_altitude_v_fuel_burn.png&quot; alt=&quot;2D Sweep_20&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Note: If you run this 400 point case yourself you may see messages indicating that a segment did not converge. This is normal and can happen when a mission is run far from a feasible point. In this case, it does not have a negative impact on the results.&lt;/p&gt;

&lt;h3 id=&quot;optimizing&quot;&gt;Optimizing:&lt;/h3&gt;

&lt;p&gt;Now try running an Optimization. Recomment &lt;code class=&quot;highlighter-rouge&quot;&gt;variable_sweep(problem)&lt;/code&gt; then uncomment the lines below:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;output = scipy_setup.SciPy_Solve(problem,solver=&#39;SLSQP&#39;)
print output
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;and run the file again.&lt;/p&gt;

&lt;p&gt;From the default inputs, the terminal (or IDE output) should display an optimum of [ 1.08980937  1.02089232], which corresponds to a wing area of 109 m^2, and 10.2 km. It appears to have found the local minimum.&lt;/p&gt;

&lt;p&gt;Now try starting the optimization from a different initial guess. You can either modify the input parameters in the initial formulation (the relevant lines are repeated below with the modification)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#   [ tag                            , initial, (lb,ub)             , scaling , units ]
problem.inputs = np.array([
    [ &#39;wing_area&#39;                    ,  128   , (   90. ,   130.   ) ,   100. , Units.meter**2],
    [ &#39;cruise_altitude&#39;              ,  13.8  , (   9   ,    14.   ) ,   10.  , Units.km],
])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;or set up the optimization problem and change the inputs manually by uncommenting the following lines.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;inputs                                   = [1.28, 1.38]
scaling                                  = problem.optimization_problem.inputs[:,3] # have to 
										   rescale inputs to start problem from here
scaled_inputs                            = np.multiply(inputs,scaling)
problem.optimization_problem.inputs[:,1] = scaled_inputs
output = scipy_setup.SciPy_Solve(problem,solver=&#39;SLSQP&#39;)
print output        
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This starts the optimization problem above the feasible region (wing area = 128 m^2, altitude = 13.8 km), and results in a fuel burn that is 30 kg lower than the result using the initial guess. This illustrates the important of choosing a starting point when running optimization problem. Additionally, this demonstrates SUAVE’s ability to handle infeasible cases, showing that it can converge to a feasible case even when starting from an infeasible set of initial inputs.&lt;/p&gt;

&lt;p&gt;At this point, you can explore other starting points, or alter the vehicle or mission properties in Vehicles.py or Missions.py. Additionally, feel free to start using this as the basis for creating custom optimization scripts.&lt;/p&gt;
</description>
        <pubDate>Sun, 14 Jun 2015 16:22:25 -0700</pubDate>
        <link>http://suavecode.github.io//guides/regional_jet_optimization.html</link>
        <guid isPermaLink="true">http://suavecode.github.io//guides/regional_jet_optimization.html</guid>
        
        
        <category>guides</category>
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Solar UAV Optimization</title>
        <description>&lt;h2 id=&quot;solar-uav-optimization-tutorial&quot;&gt;Solar UAV Optimization Tutorial&lt;/h2&gt;

&lt;p&gt;The purpose of this tutorial is to illustrate a different type of problem. We assume you have gone through the first optimization tutorial: Regional Jet Optimization. This tutorial will illustrate a little more complex setup that modifies a mission parameter.&lt;/p&gt;

&lt;p&gt;Your objective is simple: get a small UAV to fly from San Francisco to San Diego. In fact you can pose that as an optimization problem, with some constraints that govern how it works. There is no requirement to minimize this or maximize that. Of course you could try to minimize something, but you just want something that works for now. Later iterations can do fancier things.&lt;/p&gt;

&lt;p&gt;Next we will go into detail about some of the required files. &lt;em&gt;Analyses.py&lt;/em&gt; and &lt;em&gt;Plot_mission.py&lt;/em&gt; are straightforward from prior tutorials. So we will not go into those in detail, except to say that we are using a UAV weight model in &lt;em&gt;Analyses.py&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&quot;optimizepy&quot;&gt;Optimize.py:&lt;/h3&gt;

&lt;p&gt;Let’s pose the optimization problem first and then setup the rest. We start with the &lt;em&gt;Nexus&lt;/em&gt; first as usual. With this design problem there are things you are uncertain of and want to solve for.&lt;/p&gt;

&lt;p&gt;You’re not sure if you really need any solar panels on the airplane, so to start there will be none. The solar ratio is the ratio of wing area to solar area. A value of 1 would the whole top of the wing covered with solar panels.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;
	  # [ tag , initial, [lb,ub], scaling, units ]
    problem.inputs = np.array([
        [ &#39;wing_area&#39;       ,   0.5, (  0.1,    1.5 ),    0.5, Units.meter      ],
        [ &#39;aspect_ratio&#39;    ,  10.0, (  5.0,   20.0 ),   10.0, Units.less       ], 
        [ &#39;dynamic_pressure&#39;, 125.0, (  1.0, 2000.0 ),  125.0, Units.pascals    ], 
        [ &#39;solar_ratio&#39;     ,   0.0, (  0.0,    0.97),    1.0, Units.less       ], 
        [ &#39;kv&#39;              , 800.0, ( 10.0, 1500.0 ),  800.0, Units[&#39;rpm/volt&#39;]], 
    ])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next come the constraints. The first constraint is that the battery energy can never go negative, the math behind this will be elaborated on later. The next constraint is that the plane must have a battery. Finally there are limits to coefficients of lift and throttle settings.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;
      # [ tag, sense, edge, scaling, units ]
    problem.constraints = np.array([
        [ &#39;energy_constraint&#39;, &#39;=&#39;, 0.0, 1.0, Units.less],
        [ &#39;battery_mass&#39;     , &#39;&amp;gt;&#39;, 0.0, 1.0, Units.kg  ],       
        [ &#39;CL&#39;               , &#39;&amp;gt;&#39;, 0.0, 1.0, Units.less],
        [ &#39;Throttle_min&#39;     , &#39;&amp;gt;&#39;, 0.0, 1.0, Units.less],
        [ &#39;Throttle_max&#39;     , &#39;&amp;gt;&#39;, 0.0, 1.0, Units.less],
    ])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice here that all constraints are greater than zero. This is because SciPy’s SLSQP optimization algorithm assumes this form. To correct for these, the values are adjusted in Procedure.py. Other optimization packages such as PyOpt don’t require this strict form.&lt;/p&gt;

&lt;p&gt;Finally, the objective. It’s nothing of course! As long as the constraints are met, the goal of the design is satisfied.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;
    # [ tag, scaling, units ]
    problem.objective = np.array([
         [ &#39;Nothing&#39;, 1. , Units.kg],
    ])
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;vehiclespy&quot;&gt;Vehicles.py:&lt;/h3&gt;

&lt;p&gt;Next, you will setup the vehicle. This is very similar to the prior Solar UAV tutorial. So we will gloss over this, the one noticeable difference is that a lower fidelity energy network is used. This means that most components operate with prescribed efficiencies. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;
    # Component 4 the Motor
    motor = SUAVE.Components.Energy.Converters.Motor_Lo_Fid()
    kv                         = 800. * Units[&#39;rpm/volt&#39;] # RPM/volt is standard
    motor                      = size_from_kv(motor, kv)    
    motor.gear_ratio           = 1. # Gear ratio, no gearbox
    motor.gearbox_efficiency   = 1. # Gear box efficiency, no gearbox
    motor.motor_efficiency     = 0.825;
    net.motor                  = motor  
    ])
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;missionspy&quot;&gt;Missions.py:&lt;/h3&gt;

&lt;p&gt;Now for the mission setup. Here we assume it will take 1000 km and the plane will cruise off the coast at 1000 feet in altitude. The distance is a bit longer than the straight line distance, but we’re not going to fly through populated areas. The heading, or body rotation, must be set to account for the changes in latitude and longitude to accurately calculate the solar radiation. We will cruise at a constant altitude and assume it takes no time to climb and descend compared to the cruise time.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;
    segment.state.numerics.number_control_points = 50
    segment.dynamic_pressure = 115.0 * Units.pascals
    segment.start_time       = time.strptime(&quot;Tue, Jun 21  11:00:00  2016&quot;, &quot;%a, %b %d %H:%M:%S %Y&quot;,)
    segment.altitude         = 1000.0 * Units.feet
    segment.distance         = 1000.0 * Units.km
    segment.charge_ratio     = 1.0
    segment.latitude         = 37.4
    segment.longitude        = -122.15
    segment.state.conditions.frames.wind.body_rotations[:,2] = 125.* Units.degrees 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;procedurepy&quot;&gt;Procedure.py:&lt;/h3&gt;

&lt;p&gt;Finally we have the procedure setup. In the procedure, we resize the vehicle, calculate weights, finalize the analyses, solve the mission, and post process.&lt;/p&gt;

&lt;p&gt;Some notes about sizing. Each wing component (main wing, horizontal tail, and vertical tail) needs the surfaces sized based on its area and aspect ratio. Next the solar panels are sized based on the wing area and solar_ratio. Finally the motor is resized based on correlations for the speed constant of the motor.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;
def simple_sizing(nexus):
    
    # Pull out the vehicle
    vec = nexus.vehicle_configurations.base
    
    # Change the dynamic pressure based on the, add a factor of safety   
    vec.envelope.maximum_dynamic_pressure = nexus.missions.mission.segments.cruise.dynamic_pressure*1.2
    
    # Scale the horizontal and vertical tails based on the main wing area
    vec.wings.horizontal_stabilizer.areas.reference = 0.15 * vec.reference_area
    vec.wings.vertical_stabilizer.areas.reference   = 0.08 * vec.reference_area

    # wing spans,areas, and chords
    for wing in vec.wings:
        
        # Unpack
        AR = wing.aspect_ratio
        S  = wing.areas.reference
        
        # Set the spans
        wing.spans.projected = np.sqrt(AR*S)
        
        # Set all of the areas for the surfaces
        wing.areas.wetted   = 2.0 * S
        wing.areas.exposed  = 1.0 * wing.areas.wetted
        wing.areas.affected = 1.0 * wing.areas.wetted   
        
        # Set all of the chord lengths
        chord = wing.areas.reference/wing.spans.projected
        wing.chords.mean_aerodynamic = chord
        wing.chords.mean_geometric   = chord
        wing.chords.root             = chord
        wing.chords.tip              = chord

    # Size solar panel area
    wing_area                   = vec.reference_area
    spanel                      = vec.propulsors.network.solar_panel
    sratio                      = spanel.ratio
    solar_area                  = wing_area*sratio
    spanel.area                 = solar_area
    spanel.mass_properties.mass = solar_area*(0.60 * Units.kg)    
    
    # Resize the motor
    motor = vec.propulsors.network.motor
    kv    = motor.speed_constant
    motor = size_from_kv(motor, kv)    
    
    # diff the new data
    vec.store_diff()

    return nexus
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here the battery is sized and charged. The battery weight consists of everything that is left over from sizing.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;
def weights_battery(nexus):

    # Evaluate weights for all of the configurations
    config = nexus.analyses.base
    config.weights.evaluate() 
    
    vec     = nexus.vehicle_configurations.base
    payload = vec.propulsors.network.payload.mass_properties.mass  
    msolar  = vec.propulsors.network.solar_panel.mass_properties.mass
    MTOW    = vec.mass_properties.max_takeoff
    empty   = vec.weight_breakdown.empty
    mmotor  = vec.propulsors.network.motor.mass_properties.mass
    
    # Calculate battery mass
    batmass = MTOW - empty - payload - msolar -mmotor
    bat     = vec.propulsors.network.battery
    initialize_from_mass(bat,batmass)
    vec.propulsors.network.battery.mass_properties.mass = batmass
        
    # Set Battery Charge
    maxcharge = nexus.vehicle_configurations.base.propulsors.network.battery.max_energy
    charge    = maxcharge
    
    nexus.missions.mission.segments.cruise.battery_energy = charge 

    return nexus
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next we run the mission and post process the results. The post_process function will setup the information of importance for the user. The energy constraint is a way of ensuring that nowhere in the mission the battery energy goes negative. The coefficient of lift is limited to 1.2. The throttle is limited to 0.9, to make sure there is excess throttle to climb. Throttle is also limited from going negative. Finally, the objective, nothing is specified to be zero.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;
def post_process(nexus):
    
    # Unpack
    mis = nexus.missions.mission.segments.cruise
    vec = nexus.vehicle_configurations.base
    res = nexus.results.mission.segments.cruise.conditions
    
    # Final Energy
    maxcharge    = vec.propulsors.network.battery.max_energy
    
    # Energy constraints, the battery doesn&#39;t go to zero anywhere, using a P norm
    p                    = 8.    
    energies             = res.propulsion.battery_energy[:,0]/np.abs(maxcharge)
    energies[energies&amp;gt;0] = 0.0 # Exclude the values greater than zero
    energy_constraint    = np.sum((np.abs(energies)**p))**(1/p) 

    # CL max constraint, it is the same throughout the mission
    CL = res.aerodynamics.lift_coefficient[0]
    
    # Pack up
    summary = nexus.summary
    summary.CL                = 1.2 - CL
    summary.energy_constraint = energy_constraint
    summary.throttle_min      = res.propulsion.throttle[0]
    summary.throttle_max      = 0.9 - res.propulsion.throttle[0]
    summary.nothing           = 0.0
    
    return nexus    
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;results&quot;&gt;Results&lt;/h3&gt;
&lt;p&gt;Let’s look at the results: &lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;
Optimization terminated successfully.    (Exit mode 0)
            Current function value: [0.0]
            Iterations: 4
            Function evaluations: 29
            Gradient evaluations: 4
[ 1.12963146  1.43880081  1.39329626  0.65589785  0.97171879]
Design Variable Table:

[[&#39;wing_area&#39; 0.5648157324099996 (0.1, 1.5) 0.5 1.0]
 [&#39;aspect_ratio&#39; 14.388008119672202 (5.0, 20.0) 10.0 1.0]
 [&#39;dynamic_pressure&#39; 174.16203234031317 (1.0, 2000.0) 125.0 1.0]
 [&#39;solar_ratio&#39; 0.6558978486767236 (0.0, 0.97) 1.0 1.0]
 [&#39;kv&#39; 777.3750338508712 (10.0, 1500.0) 800.0 0.10471975511965977]]

Constraint Table:

[[&#39;energy_constraint&#39; 0.0 &#39;=&#39; 0.0 1.0 &amp;lt;Quantity(1.0, &#39;less&#39;)&amp;gt;]
 [&#39;battery_mass&#39; 4.939962596982861 &#39;&amp;gt;&#39; 0.0 1.0 &amp;lt;Quantity(1.0, &#39;kilogram&#39;)&amp;gt;]
 [&#39;CL&#39; 0.5309682332699428 &#39;&amp;gt;&#39; 0.0 1.0 &amp;lt;Quantity(1.0, &#39;less&#39;)&amp;gt;]
 [&#39;Throttle_min&#39; 0.7319219623084848 &#39;&amp;gt;&#39; 0.0 1.0 &amp;lt;Quantity(1.0, &#39;less&#39;)&amp;gt;]
 [&#39;Throttle_max&#39; 0.1680780376915152 &#39;&amp;gt;&#39; 0.0 1.0 &amp;lt;Quantity(1.0, &#39;less&#39;)&amp;gt;]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Okay looks like SciPy found a feasible solution without too much time. Now let’s review the plots.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/opt_battery_energy.png&quot; alt=&quot;battery_energy&quot; /&gt;&lt;/p&gt;

&lt;p&gt;So we can tell now that the battery energy doesn’t go all the way to zero. Let’s look at how the solar flux varies throughout the day and how that affects the draw from the battery.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/opt_solar_flux.png&quot; alt=&quot;solar flux&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/opt_battery_draw.png&quot; alt=&quot;battery draw&quot; /&gt;&lt;/p&gt;

&lt;p&gt;So maybe those solar panels actually are worth it. They seem to decrease the load on the battery considerably during the daytime.&lt;/p&gt;

</description>
        <pubDate>Sun, 14 Jun 2015 16:22:21 -0700</pubDate>
        <link>http://suavecode.github.io//guides/solar_uav_optimization.html</link>
        <guid isPermaLink="true">http://suavecode.github.io//guides/solar_uav_optimization.html</guid>
        
        
        <category>guides</category>
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Frequently Asked Questions</title>
        <description>&lt;link rel=&quot;stylesheet&quot; href=&quot;//cdn.jsdelivr.net/highlight.js/8.6/styles/default.min.css&quot; /&gt;

&lt;script src=&quot;//cdn.jsdelivr.net/highlight.js/8.6/highlight.min.js&quot;&gt;&lt;/script&gt;

&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;

&lt;p&gt;Alright, you dove in and now you’re stuck. You’ve come to a good starting point. If this FAQ fails you then we suggest you go through tutorials, maybe our &lt;a href=&quot;http://adl.stanford.edu/papers/suave-open-source.pdf&quot;&gt;paper&lt;/a&gt;, send us a question in the forum, or if all else fails start reading code. Don’t worry the code is more readable than most engineering textbooks.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#how-do-i-get-started&quot;&gt;How do I get started?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#what-version-of-python-should-i-use&quot;&gt;What version of Python should I use?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#can-i-use-suave-for-my-own-research&quot;&gt;Can I use SUAVE for my own research?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#how-can-i-contribute&quot;&gt;How can I contribute?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#how-can-i-best-get-in-touch-with-you-or-ask-for-help&quot;&gt;How can I best get in touch with you or ask for help?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#where-can-i-see-the-recent-additions-to-the-suave-environment&quot;&gt;Where can I see the recent additions to the SUAVE environment?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#are-there-plans-to-make-a-graphical-user-interface&quot;&gt;Are there plans to make a Graphical User Interface?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#how-is-a-mission-solved&quot;&gt;How is a mission solved?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;how-do-i-get-started&quot;&gt;How do I get started?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Download SUAVE’s current release on our &lt;a href=&quot;/download/&quot;&gt;download&lt;/a&gt; page. Specific steps and further instructions for additional software requirements are also listed there.&lt;/li&gt;
  &lt;li&gt;Get familiar with the code using our &lt;a href=&quot;guides/&quot;&gt;guides&lt;/a&gt;. Be sure to start the &lt;a href=&quot;/guides/boeing_737-800.html&quot;&gt;Boeing 737 Tutorial&lt;/a&gt; for a basic introduction and the Regional Jet Optimization for the optimization tools.&lt;/li&gt;
  &lt;li&gt;Ask any remaining questions on the &lt;a href=&quot;/forum&quot;&gt;forum&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;what-version-of-python-should-i-use&quot;&gt;What version of Python should I use?&lt;/h3&gt;
&lt;p&gt;SUAVE is developed in Python 2.7. &lt;/p&gt;

&lt;h3 id=&quot;can-i-use-suave-for-my-own-research&quot;&gt;Can I use SUAVE for my own research?&lt;/h3&gt;
&lt;p&gt;Yes, you may! Please cite our papers:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://adl.stanford.edu/papers/suave-open-source.pdf&quot;&gt;T. Lukaczyk, A. Wendorff, E. Botero, T. MacDonald, T. Momose, A. Variyar, J. M. Vegh, M. Colonno, T. Economon, J. J. Alonso, T. Orra, C. Ilario, “SUAVE: An Open-Source Environment for Multi-Fidelity Conceptual Vehicle Design”, 16th AIAA Multidisciplinary Analysis and Optimization Conference, Dallas, TX, June 2015.&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://adl.stanford.edu/papers/suave-optimization.pdf&quot;&gt;E. Botero, A. Wendorff, T. MacDonald, A. Variyar, J. M. Vegh, T. Lukaczyk, J. J. Alonso, T. Orra, C. Ilario da Silva. “SUAVE: An Open-Source Environment for Conceptual Vehicle Design and Optimization”, 54th AIAA Aerospace Sciences Meeting, San Diego, CA, January 2016.&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://adl.stanford.edu/papers/suave-hi-fi.pdf&quot;&gt;T. MacDonald, E. Botero, J. M. Vegh, A. Variyar, J. J. Alonso, T. Orra, C. Ilario da Silva. “SUAVE: An Open-Source Environment Enabling Unconventional Designs through Higher Fidelity”, 55th AIAA Aerospace Sciences Meeting, Grapevine, TX, January 2017.&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://adl.stanford.edu/papers/suave-mf-opt.pdf&quot;&gt;T. MacDonald, M. Clarke, E. Botero, J. M. Vegh, J. J. Alonso. “SUAVE: An Open-Source Environment Enabling Multi-fidelity Vehicle Optimization”, 16th AIAA Multidisciplinary Analysis and Optimization Conference, Denver, CO, June 2017.&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;how-can-i-contribute&quot;&gt;How can I contribute?&lt;/h3&gt;
&lt;p&gt;We encourage SUAVE users to expand the environment according to their personal interests.  The main areas to be developed are listed &lt;a href=&quot;/develop/#areas-of-development&quot;&gt;here&lt;/a&gt;. &lt;/p&gt;

&lt;h3 id=&quot;how-can-i-best-get-in-touch-with-you-or-ask-for-help&quot;&gt;How can I best get in touch with you or ask for help?&lt;/h3&gt;
&lt;p&gt;The &lt;a href=&quot;/forum&quot;&gt;forum&lt;/a&gt; is our main point of contact for SUAVE discussions. &lt;/p&gt;

&lt;h3 id=&quot;where-can-i-see-the-recent-additions-to-the-suave-environment&quot;&gt;Where can I see the recent additions to the SUAVE environment?&lt;/h3&gt;
&lt;p&gt;Go and check the develop branch on our &lt;a href=&quot;https://github.com/suavecode/SUAVE&quot;&gt;GitHub site&lt;/a&gt;. This branch contains new features that are functional but not necessarily ready for release. Everything in this branch is added to the master branch at the next release. Several other feature branches can also be seen here. These are typically under active development. For any more information on what is available please ask on the &lt;a href=&quot;/forum&quot;&gt;forum&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;are-there-plans-to-make-a-graphical-user-interface&quot;&gt;Are there plans to make a Graphical User Interface?&lt;/h3&gt;
&lt;p&gt;The core development team is currently not planning on developing a GUI, but you can help! Contact us via the &lt;a href=&quot;/forum&quot;&gt;forum&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;how-is-a-mission-solved&quot;&gt;How is a mission solved?&lt;/h3&gt;

&lt;p&gt;A mission is divided into segments, for example climb, cruise, etc…  Then the segment is divided into discrete points that are cosine spaced in time. These make up Chebyshev collocation points. One of the beauties of this method is the integration and differentiation operator. So if you know the velocity at every point, then you can get accelerations and vice-versa.&lt;/p&gt;

&lt;p&gt;The default value is 16 points in each segment for SUAVE. However, our internal numerical experiments have shown highly accurate results with ~0.1% error with only 4 control points and ~.0001% error with 8 as measured from a very highly refined answered.&lt;/p&gt;

&lt;p&gt;For each control point there are various unknowns and residuals. An example of an unknown would be pitch angle, and a residual would be the forces in the Z direction. After performing an analysis using the unknowns the residuals are calculated. These unknowns and residuals are iterated through a hybrid solver (much like a Newton method) in SciPy to converge the residual to zero. Voila, with a little magic you have results!&lt;/p&gt;

&lt;!--- For more information see this [guide](). --&gt;
</description>
        <pubDate>Tue, 15 Jun 2010 07:20:00 -0700</pubDate>
        <link>http://suavecode.github.io//faq.html</link>
        <guid isPermaLink="true">http://suavecode.github.io//faq.html</guid>
        
        
        <category>guides</category>
        
        <category>blog</category>
        
      </item>
    
  </channel>
</rss>
